
Міністерство освіти і науки України Харківський національний 
університет радіоелектроніки


Факультет комп’ютерних наук


Кафедра програмної інженерії

КУРСОВА РОБОТА
ПОЯСНЮВАЛЬНА ЗАПИСКА
з навчальної дисципліни «Архітектура програмного забезпечення»
Тема роботи: Програмна система для контрою роботи вовняної ферми


Студент гр. ПЗПІ-21-11            ________________                            Міленний І.А.
                                       (підпис)
Керівник роботи                        ________________                 доц. Лещинська І.О.
                                         (підпис)

Роботу захищено «__»________ 2024р. 
з оцінкою     __________________
	
Комісія:
        ________________              доц. Лещинська І.О.                                
(підпис)
	________________              доц. Лещинський В.О.
(підпис)
	 ________________              ст. викл. Сокорчук І.П.
 (підпис)


Харків 2024


Харківський національний університет радіоелектроніки


Факультет комп’ютерних наук	Кафедра програмної інженерії	
Спеціальність 121 – Інженерія програмного забезпечення	
Курс 3 Семестр	6 Навчальна дисципліна Архітектура програмного забезпечення                           


ЗАВДАННЯ
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ

Міленному Івану АНдрійовичу

1. Тема проєкту: Програмна система для контролю роботи вовняної ферми
2. Термін узгодження завдання з лабораторних робіт «27»    березня     2024 р.
3. Термін здачі завдання з лабораторних робіт «31»	      травня 	2024 р.
4. Вихідні дані до проєкту: серверна частина, клієнтська частина, IoT частина
фокус на працівниках ферми, масштабованість, локалізація, захист особистих даних, інструменти для адміністрування.                                                              
5. Зміст	пояснювальної записки (перелік	питань, що належить розробити) аркуш завдання та Vision & Scope Document, інженерні рішення, програмне забезпечення серверної частини, програмне забезпечення веб-клієнта, мобільний додаток, тестування серверної частини, діаграми, протоколи відправки даних, адміністрування системи.   
 6. Перелік графічного матеріалу (діаграми, рисунки, інтерфейси) UML діаграма прецедентів, UML діаграма компонентів, UML діаграма взаємодії, UML діаграма розгортання, схема бази даних, рисунки графічних інтерфейсів.      
 
 
                                                                                                                        
КАЛЕНДАРНИЙ ПЛАН



№
Основні етапи виконання проєкту
в рамках лабораторних робіт
Термін виконання
етапів
Примітка
1
Функціональна специфікація програмного проекту
27.03.2024-31.03.2024

2
 Розробка серверної частини
01.04.2024-21.04.2024

3
 Розробка IoT програмного        застосунку
22.04.2024-10.05.2024

4
 Розробка веб частини
11.05.2024-21.05.2024

5
 Розробка мобільного застосунку
22.05.2024-31.05.2024

6
 Оформлення пояснювальної записки
01.06.2024 -08.06.2024

7
Захист курсової роботи
08.062024-14.06.2024


Дата видачі теми проєкту «27»            березня	2024 р.


Керівник                                	                            доц. Лещинська І. О.
(підпис)


Завдання прийняв до виконання
ст.гр. ПЗПІІ-21-11
Міленний І.А.                         	                
(підпис)
				                          
РЕФЕРАТ


Пояснювальна записка до курсової роботи: 104 сторінки, 19 рисунків, 5 джерел, 4 додатки.
ВОВНЯНА ФЕРМА, СИСТЕМА КОНТРОЛЮ, IOT, RUST, REACT, ACTIX WEB, АНАЛІЗ ДАНИХ.
Об’єктом розробки є програмна система для контролю роботи вовняної ферми.
Метою даної роботи є створення комплексної системи, яка дозволяє контролювати всі процеси на вовняній фермі, включаючи моніторинг стану здоров'я овець, управління графіками годування та стрижки, облік кормів. Це повинно забезпечити високий рівень ефективності, зниження витрат та підвищення якості продукції.
Методи, застосовані для розробки даної програмної системи, включають використання мови програмування Rust та фреймворку Actix Web для серверної частини, що забезпечує надійне зберігання та обробку даних у базі даних MySQL. IoT частина реалізована за допомогою сенсорів для моніторингу температури овець та передачі даних на сервер. Веб-клієнт розроблений на основі React, що забезпечує зручний та інтуїтивно зрозумілий інтерфейс для користувачів. Мобільний додаток на базі Kotlin дозволяє вівчарям та комірникам зручно управляти даними та отримувати необхідну інформацію в реальному часі.
Результатом виконання курсової роботи стала розробка комплексної  програмної системи для контролю роботи вовняної ферми, що включає серверну частину, IoT компоненти та клієнтські додатки для веб і мобільних пристроїв. Запропонована система дозволяє значно підвищити ефективність управління фермою, зменшити ручну працю та мінімізувати помилки через людський фактор.
Розроблена система сприяє покращенню догляду за тваринами, оптимізації виробничих процесів та підвищенню рентабельності господарства. Це забезпечує зручність та безпеку для фермерів, а також дозволяє своєчасно вживати необхідних заходів для запобігання захворюванням та інших проблем. Система має великий потенціал для подальшого розвитку та впровадження у різних фермерських господарствах, що займаються вирощуванням овець.

ЗМІСТ


ВСТУП	8
1 АНАЛІЗ ПРЕДМЕТНОЇ ГАЛУЗІ	10
1.1 Аналіз предметної області	10
1.2 Аналіз існуючих аналогів	11
1.3 Концептуальне моделювання	12
2 ПОСТАНОВКА ЗАДАЧІ	19
2.1 Основна функціональність системи	19
2.2 Рамки первинного випуску	20
2.3 Рамки наступних випусків	23
2.4 Припущення та залежності	23
2.5 Робоче середовище	25
3 СТРУКТУРА БАЗИ ДАНИХ	26
3.1 Побудова ER-моделі даних	26
4 ПРОЕКТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ	30
4.1 Побудова діаграми компонентів та розгортання	30
5 ОПИС РЕАЛІЗАЦІЇ ПРОГРАМНОЇ СИСТЕМИ	33
5.1 Серверна частина	33
5.2 IoT частина	39
5.2 Веб-клієнт	44
6 ОСОБЛИВОСТІ ЗАСТОСУВАННЯ	56
ВИСНОВКИ	58
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ	60
ДОДАТОК А Код реалізації логіки сервера	61
А.1 Файл main.rs	61
А.2 Модуль sheep_service.rs	64
А.3 Модуль sheep_endpoints.rs	72
А.4 Модуль utils.rs	76
А.5 Модуль configure.rs	78
ДОДАТОК Б Код реалізації логіки IoT частини	83
Б.1 Файл main.rs	83
Б.2 Модуль utils.rs	85
Б.3 Модуль auth.rs	86
Б.4 Модуль temperature.rs	88
Б.5 Модуль scanner_error.rs	90
ДОДАТОК В Код реалізації логіки веб-клієнта	91
В.1 Компонент Router.tsx	91
В.2 Файл SheepService.ts	94
В.3 Модуль helpers.ts	98
ДОДАТОК Г Графічні інтерфейси веб-клієнта	102

ВСТУП


У сучасному світі фермерські господарства стикаються з постійно зростаючими вимогами до ефективного контролю за тваринами та управління ресурсами. Вовняні ферми, зокрема, потребують високого рівня догляду за вівцями для забезпечення якості продукції. Зростання ефективності процесів, зниження витрат та покращення якості продукції стають ключовими завданнями для таких господарств.
Метою даної курсової роботи є розробка програмної системи для контролю роботи вовняної ферми, яка забезпечить ефективний збір, аналіз та візуалізацію даних щодо стану здоров'я овець, умов утримання, годування та інших важливих параметрів. Запропонована система сприятиме зменшенню ручної праці, мінімізації помилок через людський фактор та підвищенню загальної продуктивності ферми.
Система складається з чотирьох основних частин: серверної, IoT, веб-клієнта та мобільного додатку. Кожна з цих частин виконує свої специфічні функції та взаємодіє з іншими компонентами системи для досягнення загальної мети. Серверна частина буде розроблена за допомогою мови програмування Rust та фреймворку Actix Web, що забезпечить надійне зберігання та обробку даних у базі даних MySQL. IoT частина забезпечить збір та передачу даних про температуру тварин. Веб-клієнт, розроблений на основі React, надасть користувачам зручний інтерфейс для управління системою. Мобільний додаток на базі Kotlin забезпечить мобільний доступ до даних та функцій системи.
У звіті детально розглянуто процес розробки кожної з частин системи, наведено технічні рішення та особливості реалізації. Також проведено аналіз предметної області та існуючих аналогів, що дозволило визначити основні переваги розроблюваної системи та можливі напрямки її подальшого розвитку. 	Враховуючи зростаючу потребу в автоматизації та ефективному управлінні фермерськими процесами, розроблена система може стати важливим інструментом для досягнення цих цілей та підвищення рентабельності вовняних ферм.

1 АНАЛІЗ ПРЕДМЕТНОЇ ГАЛУЗІ
1.1 Аналіз предметної області


Сучасні фермерські господарства стикаються зі зростаючими вимогами до ефективного контролю за тваринами та управління ресурсами. Це стосується також і вовняних ферм, де важливо забезпечити високий рівень догляду за вівцями для отримання якісної продукції. Підвищення ефективності процесів, зниження витрат та покращення якості продукції стають ключовими завданнями для таких господарств.
Потреба у моніторингу стану тварин на вовняних фермах стає все більш актуальною. Наявність точної інформації про стан здоров'я та як тварина доглядається є критично важливою для забезпечення успішної роботи ферми. 	Це дозволяє не лише покращити догляд за тваринами, але й оптимізувати виробничі процеси.
Автоматизація контролю за процесами також сприяє значному зменшенню ручної праці та помилок, що виникають через людський фактор. Використання сучасних технологій дозволяє фермерським господарствам відстежувати та контролювати всі аспекти управління фермами в реальному часі. Це включає моніторинг здоров'я тварин, оптимізацію графіку годівлі та стрижки, а також забезпечення належних умов утримання. Завдяки цьому, фермери можуть своєчасно вживати необхідних заходів для запобігання захворюванням та інших проблем, що позитивно впливає на продуктивність та рентабельність господарства.
Основна мета розробки програмної системи автоматизації керування вовняною фермою полягає у створенні ефективного інструменту для збору, аналізу та візуалізації даних щодо стану здоров'я овець, умов утримання, годування та інших важливих параметрів. Ця система покликана забезпечити широку доступність та зрозумілість інформації для фермерів, що дозволить їм приймати обґрунтовані рішення та розробляти стратегії для покращення ефективності роботи ферми та якості продукції.

1.2 Аналіз існуючих аналогів


Система для контролю роботи вовняної ферми відкриває широкі можливості для оптимізації та контролю над фермерськими процесами, що забезпечує підвищення ефективності та якості продукції вовняних ферм.
У порівнянні з такими конкурентами, як FarmIQ та Shearwell Data, розроблюєма програмна система має кілька ключових переваг. По-перше, головною перевагою є можливість менеджменту та обліку ресурсів ферми, здебільшого кормів. По-друге розроблюєма система буде мати зручний та інтуітивно зрозумілий інтерфейс, який полегшить використання навіть для користувачів без технічного досвіду. 
Модель монетизації  системи може включати в себе різні підходи, такі як різні плани платних підписок для малих, середніх та великих вовняних ферм, які бажають спростити контроль за своїми процесами, підвищіти продуктивність та якість продукції. Також для клієнтів, які вже користуються системою тривалий час, можна зробити послугу з надання спеціаліста, який на основі зібраних даних зможе допомогти налаштувати та оптимізувати фермерські процеси.
Цільова аудиторія – це власники вовняних ферм, які шукають способи збільшити ефективність свого господарства, а також їх підлеглі які будуть використовувати систему під час роботи. З урахуванням зростаючої уваги до ефективного управління фермерськими господарствами та покращення якості продукції, розроблюєма система може стати важливим інструментом для досягнення цих цілей та підвищення рентабельності вовняних ферм.

1.3 Концептуальне моделювання


Робота розпочалася з концептуального моделювання предметної області, що дозволить в подальшому створити діаграми прецедентів і побудувати базу даних для даної системи.
Концептуальна модель предметної області зосереджена на розробці програмної системи для контролю роботи вовняної ферми. Основне призначення системи полягає у створенні інфраструктури, яка може бути інтегрована у вовняні ферми для полегшення моніторингу робочих процесів на фермі, контролю працівників, ресурсів ферми, овець та їх продуктивності. Ця система спрямована на підвищення ефективності та точності управління фермою за рахунок автоматизації та централізації даних.
Предметна область включає п’ять типів користувачів. Перший тип — це неавторизований користувач, який, використовуючи веб-клієнт або мобільний додаток, має можливість тільки авторизуватись. Другий тип – це вівчар, який, використовуючи веб-клієнт або мобільний додаток, має можливість взаємодіяти з серверною частиною системи, користуватися її функціями та переглядати необхідну інформацію про овець, а також відмічати годування та стрижки. Третій тип – це комірник, який, також за допомогою веб-клієнта або мобільного додатку, може взаємодіяти з серверною частиною та виконувати свої обов'язки. Він відповідає за контроль ресурсів ферми, таких як кількість кормів і їх витрати, а також відмічає нові поставки кормів. Четвертий тип користувача – це фермер або бізнес-адміністратор, який через веб-клієнт може маніпулювати певними даними та процесами за допомогою графічного інтерфейсу. Основні функції цього типу користувача включають додавання нових комірників, вівчарів, овець, порід, кормів та сканерів температури. Крім того, фермер визначає, за якими вівцями буде доглядати вівчар, та який температурний сканер буде використовуватися для вимірювання температури овець. П’ятий тип користувача – це адміністратор бази даних, який має змогу безпосередньо взаємодіяти з серверною частиною та базою даних системи. Він має доступ до всіх методів маніпулювання даними, забезпечуючи їх цілісність та актуальність, що є критично важливим для стабільної роботи системи. Крім того, в системі використовується температурний сканер, який здатний вимірювати температуру овець та зберігати ці дані завдяки інтеграції з серверною частиною системи. Інформація, зібрана сканером, допомагає забезпечити здоров'я тварин та своєчасно реагувати на будь-які відхилення від нормальних параметрів. Таким чином, предметна область охоплює різні аспекти функціонування вовняної ферми, забезпечуючи інтеграцію та ефективну взаємодію між усіма типами користувачів та компонентами системи. Це сприяє покращенню управління фермою, підвищенню продуктивності та створенню оптимальних умов для догляду за вівцями.
Першим типом користувача є неавторизований користувач. Йому доступна лише функція авторизації.
Описані функціональні потреби повністю відповідають необхідним для неавторизованого користувача функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 1.1.


Рисунок 1.1 – Діаграма прецедентів для неавторизованого користувача

Вівчар є одним з двох основних типів користувачів для даної предметної області. Він повинен мати доступ до списку овець, які закріплені за ним, списку порід та кормів, що знаходяться на фермі. Вівчар також повинен мати змогу переглядати детальну інформацію про кожну з овець, які закріплені за ним, включаючи їхню температуру та дати останніх стрижок і годувань. Крім того, вівчар повинен мати доступ до історії записів про годування та стрижки овець. 	Важливо, щоб вівчар мав змогу додавати нові записи у випадку, якщо він підстриг або погодував вівцю.
Описані функціональні потреби повністю відповідають необхідним для вівчаря функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 1.2.


Рисунок 1.2 – Діаграма прецедентів для вівчаря

Комірник є ще одним типом користувачів системи, призначеним для управління ресурсами ферми. Комірник має доступ до функції перегляду списку кормів, що є основною функцією. Також комірник може створювати відмітки про поставку корму, що є важливою частиною підтримання актуальної інформації про наявність ресурсів на фермі. Крім того, комірник може переглядати список поставок корму. Це дозволяє йому відстежувати історію поставок та планувати майбутні потреби. Ще одна функція – це перегляд списку годувань кормом, що допомагає комірнику контролювати витрати кормів і забезпечувати, щоб усі тварини отримували необхідне харчування.
Описані функціональні потреби повністю відповідають необхідним для комірника функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 1.3.


Рисунок 1.3 – Діаграма прецедентів для комірника

Фермер (бізнес-адміністратор) є ключовим користувачем системи, який має доступ до широкого спектру функцій через адмін-панель.  Основною функцією фермера є доступ до адмін-панелі, що дозволяє йому виконувати різні операції, такі як перегляд, додавання, редагування та видалення даних. Через адмін-панель фермер може управляти всіма аспектами ферми. Він має можливість переглядати історію годувань, стрижок і поставок кормів, а також видаляти ці записи при необхідності. Фермер також може переглядати список усіх комірників, вівчарів та овець. Він має змогу додавати нових комірників та вівчарів, редагувати їх або видаляти. Щодо овець, фермер може переглядати інформацію про них, додавати нових овець, редагувати та видаляти їх. Крім того, він має доступ до інформації про всі породи овець на фермі, кормів та температурних сканерів. Це дозволяє фермеру додавати нові корми та породи, редагувати існуючі записи та видаляти їх. Додатково фермер може переглядати інформацію про всі температурні сканери, а також додавати, редагувати та видаляти їх. Важливою функцією є можливість призначати сканери для вимірювання температури конкретних овець, а також призначати вівчарів для догляду за конкретними овець.
Описані функціональні потреби повністю відповідають необхідним для фермера (бізнес-адміністратора) функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 1.4.


Рисунок 1.4 - Діаграма прецедентів для фермера (бізнес-адміністратора)

Адміністратор бази даних є ще одним важливим типом користувачів системи, який повинен мати прямий доступ до серверного додатку, щоб мати повний доступу  до усіх функцій та бази даних.  Адміністратор бази даних має можливість здійснювати різні операції з даними. В першу чергу, він володіє повним доступом до бази даних, що дозволяє йому виконувати основні дії, такі як додавання, редагування, перегляд та видалення даних. Функція додавання дозволяє адміністратору вводити нові записи до бази даних, забезпечуючи актуальність та повноту інформації. Редагування дає змогу змінювати існуючі записи, вносячи необхідні корективи та оновлення. Перегляд забезпечує доступ до даних для аналізу та перевірки їхньої точності. Видалення дає змогу видаляти застарілі або некоректні записи, підтримуючи чистоту та релевантність бази даних.
Описані функціональні потреби повністю відповідають необхідним для адміністратора функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 1.5.


Рисунок 1.5 – Діаграма прецедентів для адміністратора бази даних

Температурний сканер це Smart Device, який також може використовувати систему. Його основна задача це вимірювання температури вівці, а також її оновлення  у базі даних. Для доступу до цих функції сканер має спочатку пройти автентифікацію при запуску.
Описані функціональні потреби повністю відповідають необхідним для температурного сканера функціям функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 1.6.


Рисунок 1.6 – Діаграма прецедентів для температурного сканера

Під час моделювання предметної області було виділено основні види користувачів для даної програмної системи та їхній функціонал, який був описаний, а також представлений у вигляді діаграм прецедентів.

2 ПОСТАНОВКА ЗАДАЧІ
2.1 Основна функціональність системи


Основна функціональність системи:
	MF-1: Моніторинг температури вівці – система здатна вимірювати температуру тіла вівці;
	MF-2: Розрахування графіку годування вівці;
	MF-3: Розрахування графіку стрижки вівці;
	MF-4: Розрахування кількості корму для вівці;
	MF-5: Функція авторизації вівчаря у мобільному додатку та веб-клієнті системи;
	MF-6: Вівчар зможе переглядати овець, які за ним закріплені;
	MF-7: Вівчар зможе переглядати існуючі породи та інформацію про них; 
	MF-7: Вівчар зможе переглядати існуючі корма та інформацію про них; 
	MF-8: Вівчар зможе переглядати деталі про кожну з овець, які за ним закріплені;
	MF-9: Вівчар зможе робити відмітки про стрижку вівці;
	MF-10: Вівчар зможе робити відмітку про годування вівці;
	MF-11: Вівчар зможе переглядати записи про годування вівці;
	MF-12: Вівчар зможе переглядати записи про стрижки вівці;
	MF-13: Вівчар зможе сканувати QR-кодів для швидкого доступу до інформації про вівцю;
	MF-13: Функція надсилання повідомлення вівчарю про необхідність погодувати вівцю;
	MF-14: Функція надсилання повідомлення вівчарю про необхідність підстригти вівцю;
	MF-15:  Функція авторизації комірника у мобільному додатку та веб-клієнті системи;
	MF-16: Комірник зможе переглядати всі існуючі корма та інформацію про них;
	MF-17:  Комірник зможе бачити записи витрат корму фермою;
	MF-18:  Комірник зможе бачити записи постачань корму на ферму;
	MF-19: Комірник зможе відмічати нові постачання корму на ферму;
	MF-20: Адміністратор зможе закріплювати овець за вівчарями;
	MF-21: Адміністратор зможе закріплювати сканери температури за вівцями;
	MF-22: Адміністратор зможе робити CRUD операції із породами;	
	MF-23: Адміністратор зможе робити CRUD операції із вівцями;
	MF-24: Адміністратор зможе робити CRUD операції із вівчарями;
	MF-25: Адміністратор зможе робити CRUD операції із кормами;
	MF-26: Адміністратор зможе робити CRUD операції із комірниками;
	MF-27: Адміністратор зможе робити CRUD операції із сканерами температури.

2.2 Рамки первинного випуску


Для опису функціоналу системи для контролю роботи вовняної, її було розділено на 4 частини: сервер, IoT, веб-клієнт та мобільний додаток.
Функції серверної частини:
    • сервер повинен мати графічний інтерфейс для адміністрування, тестування та обслуговування;
    • сервер повинен забезпечити зберігання даних вівчарів, комірників, кормів, порід, овець, сканерів температури, графіків годувань та стрижок, постачання кормів;
    • сервер повинен мати змогу працювати із сканерами температури для оновлення температури овець;
    • сервер повинен надавати інструменти адміністрування та обслуговування.
Функції IoT частини:
    • збір даних про температуру вівці;
    • відправка зібраних даних на сервер.
Функції веб-клієнта:
    • авторизації: змогу авторизуватись будуть мати вівчарі, комірники та адміністратор;
    • сторінка адміністратора, використовуючи яку, адміністратор зможе маніпулювати всіма даними системи;
    • підтримка двох мов, а саме українська та англійська локалізації;
    • перегляд вівчарем даних про овець які за ним закріплені. Вівчар зможе переглядати таку інформацію як номер вівці, порода, дати останнього годування та стрижки;
    • перегляд вівчарем даних про корма. Вівчар зможе переглядати таку інформацію як назва корму, кількість корму на складі, калорійність, вміст жирів, білків та вуглеводів, назву породи яка споживає цей корм та кількість овець;
    • перегляд вівчарем даних про породи. Вівчар зможе переглядати таку інформацію як назва породи, назва корму для цією породи, кількість овець та інформацію;
    • перегляд вівчарем детальних даних про вівцю. Вівчар зможе переглядати таку інформацію як номер вівці, порода, інформацію про породу, стать, вік у днях, вага, назва корму, необхідна кількість корму для годування, доступна кількість корму, дати останнього годування та стрижки, температура, потреби у годуванні та стрижці;
    • додавання вівчарем звіту про годування вівці. Функція, що дозволяє вівчарям зберігати інформацію про час годування, виконавця та кількість використаного корму;
    • додавання вівчарем звіту про стрижку вівці. Функція, що дозволяє вівчарям зберігати інформацію про час стрижки, виконавця та кількість отриманої вовни;
    • перегляд вівчарем записів про годування вівці. Вівчар зможе переглядати таку інформацію як номер запису, номер вівці, ім’я та прізвище виконавця, кількість використаного корму та дату годування;
    • перегляд вівчарем записів про стрижку вівці. Вівчар зможе переглядати таку інформацію як номер запису, номер вівці, ім’я та прізвище виконавця, кількість отриманої вовни та дату годування;
    • перегляд комірником всіх видів кормів, які є на фермі. Комірник зможе переглядати таку інформацію як назва корму, кількість корму на складі, назву породи, яка споживає цей корм та кількість овець;
    • перегляд комірником записів про годування овець обраним кормом. Комірник зможе переглядати таку інформацію як номер запису, номер вівці, ім’я та прізвище виконавця, кількість використаного корму та дату годування;
    • перегляд комірником інформацію про постачання обраного корму. Комірник зможе переглядати таку інформацію як номер постачання, ім’я та прізвище виконавця, кількість отриманого корму та дату постачання;
    • додавання комірником постачання корму.
Функції мобільного додатку: 
    • авторизації: змогу авторизуватись будуть мати вівчарі та комірники;
    • сканування QR-коду на загоні з вівцею для швидкого отримання детальної інформацію про вівцю;
    • перегляд вівчарем детальних даних про вівцю. Вівчар зможе переглядати таку інформацію як номер вівці, порода, інформацію про породу, стать, вік у днях, вага, назва корму, необхідна кількість корму для годування, доступна кількість корму, дати останнього годування та стрижки, температура, потреби у годуванні та стрижці;
    • додавання вівчарем звіту про годування вівці. Функція, що дозволяє вівчарям зберігати інформацію про час годування, виконавця та кількість використаного корму;
    • додавання вівчарем звіту про стрижку вівці. Функція, що дозволяє вівчарям зберігати інформацію про час стрижки, виконавця та кількість отриманої вовни;
    • надсилання повідомлень вівчарям про необхідність погодувати або підстригти вівцю;
    • перегляд комірником всіх видів кормів, які є на фермі. Комірник зможе переглядати таку інформацію як назва корму, кількість корму на складі, назву породи, яка споживає цей корм та кількість овець;
    • додавання комірником постачання корму.

2.3 Рамки наступних випусків


Функції, які плануються реалізувати у майбутньому:
    • розширення функціоналу для комірника шляхом додавання модулю управління запасами ветеренарних препаратів;
    • система попередження про можливе захворювання вівці, яка буде використовувати дані з IoT сенсорів.

2.4 Припущення та залежності


Припущення:
    - припускається, що всі необхідні дані для роботи системи, такі як інформація про овець, корма, породи та інші параметри, будуть доступні і зберігатимуться у базі даних MySQL;
    - припускається, що дані, отримані від IoT пристроїв про температуру овець, будуть точними та своєчасними, що дозволить ефективно використовувати їх для моніторингу здоров'я тварин;
    - припускається, що всі компоненти системи, включаючи сканери температури та інші IoT пристрої, будуть сумісними та працюватимуть без збоїв у взаємодії один з одним;
    - припускається, що інтернет-з'єднання буде стабільним і надійним, що дозволить забезпечити безперебійний обмін даними між компонентами системи;
    - припускається, що серверна інфраструктура, на якій розгорнута система, буде надійною та здатною забезпечити необхідну продуктивність і масштабованість;
    - припускається, що обслуговуючий персонал буде мати необхідну кваліфікацію для управління та підтримки системи.
Залежності:
    - система залежить від постачальників IoT пристроїв та сканерів температури. Будь-які затримки або проблеми з постачанням можуть вплинути на терміни реалізації проекту та ефективність роботи системи;
    - система залежить від надійності та функціональності програмного забезпечення, яке використовується для управління та моніторингу. Будь-які помилки або збої у програмному забезпеченні можуть негативно вплинути на роботу системи;
    - система залежить від наявності інфраструктури, такої як електричні мережі та комунікаційні канали. Будь-які перебої у роботі інфраструктури можуть вплинути на стабільність роботи системи.
	Врахування цих припущень і залежностей дозволить більш точно оцінити можливі ризики та забезпечити успішну реалізацію програмної системи для контролю роботи вовняною фермою.

2.5 Робоче середовище


Серверна частина буде розроблена за допомогою мови програмування Rust та фреймворку Actix Web, який надає інструменти для розробки REST API. Для розгортання сервера буде використовуватись Docker та Azure Container Registry. Для збереження  даних та маніпулювання ними, була обрана система управління базами даних MySQL. Для розгортання бази даних також буде використовуватись Microsoft Azure.
Для створення веб-клієнта буде використовуватись мова програмування TypeScript та його фреймворк React. Для надання сайту гарного зовнішнього вигляду будуть використовуватись каскадні таблиці стилів CSS. Для розгортання сайту буде використовуватись хмарна платформа Netlify. 
Для мобільного додатку буде використовуватись мова програмування Kotlin. Додаток планується під платформу Android.
IoT застосунок, буде розроблений з використанням мови програмування Rust.
Основні вимоги:
    • система повинна стабільно функціонувати цілодобово, та бути доступною для робітників підприємств;
    • архітектура системи, яка дозволить легко її підтримувати, оновлювати та додавати нові функції;
    • оптимізація системи з метою функціонування під великими навантаженнями;
    • забезпечення приватності за допомогою шифрування та засобів обмеження доступу.
    
3 СТРУКТУРА БАЗИ ДАНИХ
3.1 Побудова ER-моделі даних


Спираючись на отриману модель предметної області була побудована схема бази даних, яка зможе зберігати всю інформацію, необхідну для реалізації описаної функціональності.
Було виділено 9 сутностей: породи, поставки кормів, записи годувань, корми, записи стрижок, вівці, вівчарі, комірники, температурні сканери.
Виділені сутності отримали наступні атрибути:
    • породи: id, feed_id, назва, інформація про породу. Первинний ключ: id. Зовнішній ключ: feed_id (має бути унікальним);
    • поставки кормів: id, комірник_id, корм_id, кількість корму, часова мітка коли була зроблена поставка. Первинний ключ: id. Зовнішні ключі: корм_id, комірник_id (може бути відсутнім);
    • записи годувань: id, вівця_id, вівчар_id, корм_id, кількість витраченого корму, часова мітка коли було відмічено годування. Первинний ключ: id. Зовнішні ключі: вівця_id, корм_id, вівчар_id (може бути відсутнім);
    • корми: id, кількість корму, назва, калорійність, жири, білки, вуглеводи. Первинний ключ: id;
    • записи стрижок: id, вівця_id, вівчар_id, кількість отриманої вовни, часова мітка коли була відмічена стрижка. Первинний ключ: id. Зовнішні ключі: вівця_id, вівчар_id (може бути відсутнім);
    • вівчарі: id, ім’я користувача, пароль, ім’я, прізвище. Первинний ключ: id;
    • комірники: id, ім’я користувача, пароль, ім’я, прізвище. Первинний ключ: id;
    • температурні сканери: id, пароль, температура. Первинний ключ: id;
    • вівці: id, вівчар_id, порода_id, сканер_id, часова мітка дати народження, стать, вага. Первинний: id. Зовнішні ключі:  вівчар_id (може бути відсутнім), порода_id, сканер_id (може бути відсутнім або має бути унікальним).
Позначимо зв’язки між сутностями:
    • "породи - корми" – тип зв’язку “один до одного”, оскільки кожна порода має асоційований корм.
    • "корми - поставки кормів" – тип зв’язку “один до багатьох”, оскільки для кожного корму може бути багато поставок.
    • "комірники  - поставки кормів" – тип зв’язку “один до багатьох”, кожен комірник може обробляти багато поставок.
    • "вівці - записи годувань" – тип зв’язку “один до багатьох”, оскільки кожна вівця може мати багато записів годувань.
    • "вівчарі - записи годувань" – тип зв’язку “один до багатьох”, оскільки один вівчар може виконувати багато годувань.
    • "корми - записи годувань" – тип зв’язку “один до багатьох”, оскільки для кожного корму може бути багато записів годувань.
    • "вівці - записи стрижок" – тип зв’язку “один до багатьох”, оскільки кожна вівця може мати багато записів стрижок.
    • "вівчарі - записи стрижок" – тип зв’язку “один до багатьох”, оскільки кожен вівчар може виконувати багато стрижок.
    • "породи  - вівці" – тип зв’язку “один до багатьох”, оскільки кожна порода може мати багато овець;
    • "вівчарі  - вівці" – тип зв’язку “один до багатьох”, оскільки кожен вівчар може доглядати за багатьма вівцями;
    • "температурні сканери - вівці" – тип зв’язку “один до одного”, оскільки кожна вівця може мати асоційований температурний сканер.
Діаграма ER моделі даних на якій відображено вказані сутності та зв’язки зображена на рисунку 3.1.


Рисунок 3.1 – Діаграма ER моделі даних

Для зберігання даних про вагу було прийнято рішення використовувати грами так як це покращує точність збереженої інформації та полегшує конвертацію у інші одиниці виміру ваги. Температура від сканера температури зберігається у десятих долях градусів цельсію це також покращує точність збереженої інформації та полегшує конвертацію у інші одиниці виміру температури. Дати зберігаються у вигляді часових міток, це дозволяю за рахунок використання меншого обсягу пам’яті зберігати дати з точністю до секунд, також клієнтські частини зможуть легко відображати коректну дату враховуючи часовий пояс користувача. Такий підхід уніфікації зберігання різноформатних даних суттєво покращує інтернаціоналізацію серверу та потенційну інтерналізацію клієнтських додатків, дає можливість відображати дані як метричній так і в американській імперичній системах вимірювання, дає можливість підтримувати локальний, універсальний або будь-який інший час.

4 ПРОЕКТУВАННЯ ПРОГРАМНОЇ СИСТЕМИ
4.1 Побудова діаграми компонентів та розгортання


Програмна система призначена для контролю роботи вовняної ферми. Вона реалізована на мові програмування Rust [1] з використанням фреймворку Actix Web [2] для створення REST API, що забезпечує комунікацію між клієнтськими частинами та сервером. Система використовує HTTP протокол для передачі даних, причому кожен API метод має свою адресу та параметри. 	Дані, що надходять на сервер або відправляються з нього за допомогою HTTP, представлені у форматі JSON. REST API було обрано завдяки його простоті в реалізації та масштабованості. Така архітектура дозволяє легко інтегрувати різні клієнтські частини, включаючи веб-клієнт, мобільний додаток та пристрої IoT.
Фронтенд-частина системи, реалізована за допомогою фреймворку React і збирача Vite [3], взаємодіє з сервером через REST API, отримуючи та відправляючи дані у форматі JSON. Це забезпечує швидку та зручну розробку інтерфейсів користувача, які можуть динамічно оновлюватись відповідно до стану даних на сервері. Компонентна архітектура веб-клієнта включає складні залежності між окремими компонентами, що дозволяє досягти високого рівня інтеграції та узгодженості в роботі додатка.
Мобільний додаток, розроблений для платформи Android, використовує аналогічну схему взаємодії з сервером через REST API. Це дозволяє користувачам отримувати актуальну інформацію та надсилати дані з будь-якого місця, забезпечуючи мобільність та доступність управління фермою.
Пристрої IoT, які використовуються для моніторингу температури та інших параметрів, також інтегруються з системою через REST API. Вони відправляють зібрані дані на сервер, де вони обробляються та зберігаються, що дозволяє забезпечити оперативний контроль за станом тварин та умовами їх утримання.
Для збереження інформації, що стосується працівників, овець, кормів, записів, сканерів та іншої інформації було обрано систему управління бази даних MySQL. MySQL Server на якому буде запущена база даних буде знаходитись на окремому сервері.
 На діаграмі компонентів показана взаємодія компонентів системи між собою (див. рисунок 4.1).


Рисунок 4.1 - Діаграма  компонентів

На діаграмі розгортання зображена логіка програмної системи, основні технології, принцип роботи та компоненти системи (див. рисунок 4.2).


Рисунок 4.2 – Діаграма розгортання

5 ОПИС РЕАЛІЗАЦІЇ ПРОГРАМНОЇ СИСТЕМИ
5.1 Серверна частина


Серверна частина була розбита на блоки за для зручності розробки та подальшої підтримки програми. Було виділено наступні компоненти: models, view_modles, json_structures, db, endpoints, configs.  
Модуль models містить собой структури з полями, які представляють собою сутності в базі даних.
Модуль view_models містить структури, які дозволяють представити дані у форматі, який потрібно відправити на клієнтську частину, наприклад на веб-клієнт або мобільний додаток. Ці структури призначені для перетворення даних з формату бази даних у формат, зручний для користувача, забезпечуючи тим самим правильне відображення інформації на стороні клієнта.
Модуль json_structures містить структури, які використовуються для представлення тіла деяких POST або PATCH, наприклад це може бути структура яка містить дані для авторизації.
Модуль db складається з двох підмодулів, а саме services та traits. Створення цього модулю є результатом використання патерну Repository. Модуль traits містить в собі трейти, це аналог інтерфейсів з об’єктно орієнтованих мов, що описують методи, які будуть реалізовані для сервісів. Використання трейтів спрощує розробку, оскільки дозволяє створити рівень абстракції між реалізацією метода та модулем, який використовує метод. У модулі services знаходяться сервіси, які реалізовують свої трейти та їх методи для взаємодії з даними. Кожен сервіс працює з однією конкретною сутністю в базі даних та її представленням з модуля models. Методи сервісів містять SQL запити, які взаємодіють з базою даних, та бізнес-логіку для роботи з даними з бази даних.
Модуль endpoints містить в собі методи, які викликають методи сервісів для взаємодії з даними, управляють помилками, надсилають відповіді клієнту та виконують логування. Ці методи забезпечують маршрутизацію запитів, обробку даних і відправку відповідей, гарантуючи правильну взаємодію між клієнтською та серверною частинами програми.
Модуль configs містить файли конфігурації, у яких знаходяться функції, які реєструють методи з сервісів та їх адреси у сервері. Також цей модуль містить код конфігурації Swagger UI та логування. Конфігурація Swagger UI дозволяє автоматично генерувати документацію для API, що значно полегшує тестування та інтеграцію системи. Логування забезпечує запис важливих подій і помилок, що сприяє легкому моніторингу та налагодженню роботи системи. 
Щоб серверний додаток міг взаємодіяти з базою даних MySQL, було використано пакет sqlx. Цей пакет дозволяє відправляти запити до бази даних та автоматично обробляє серіалізацію та десеріалізацію структур під час запису та зчитування даних з бази.
Для забезпечення зручності використання серверної програми адміністратором бази даних, було вирішено інтегрувати Swagger. Swagger надає графічний інтерфейс, який спрощує процес розгортання та підтримки REST API. Крім того, використання Swagger дозволило уникнути написання тестів, оскільки цей інструмент забезпечує просте та швидке тестування методів і демонстрацію їхньої роботи.
Також було прийнято рішення додати можливість логування з використанням пакет flexi_logger. Цей пакет надає можливість гнучко налаштувати логування, що робить його зручним для використання у різних середовищах, таких як розробка, тестування та продакшн. flexi_logger дозволяє налаштовувати рівні логування, такі як debug, info, warn та error, що допомагає фільтрувати логування відповідно до важливості повідомлень. Крім того, пакет підтримує ротацію логів, тобто автоматичне створення нових файлів після досягнення певного розміру або за певний період, що забезпечує зручність у зберіганні та аналізі логів. Він також дозволяє легко змінювати формат логів, додаючи до них часові мітки, рівні логування та іншу корисну інформацію. Використання flexi_logger забезпечує надійне та зручне логування, що є важливим аспектом для підтримки та моніторингу роботи системи.
У методі main (див. Додаток А пункт А.1) програми відбувається налаштування та запуск серверу. Спочатку завантажуються змінні середовища, які містять конфігураційну інформацію, таку як IP-адреса, порт і рядок підключення до бази даних. Ці змінні середовища використовуються для налаштування параметрів серверу і підключення до бази даних MySQL. Після цього створюється контекст бази даних, який використовується для створення різних сервісів, таких як BreedService, FeedService, FeedSupplyService, FeedingLogService, ShearingLogService, SheepService, ShepherdService, StorekeeperService та TemperatureScannerService. Кожен з цих сервісів відповідає за взаємодію з конкретною сутністю в базі даних. Далі налаштовується логування для відстеження подій і помилок. Основна частина методу main включає налаштування та запуск HTTP сервера. Створюється новий додаток App, в який додаються всі сервіси, налаштовуються CORS, та реєструється Swagger UI для автоматичного генерування документації API. Налаштування CORS, містять перелік адресс, які можуть мати доступ до серверу, а також типи методів з хедерами, які можуть поступати на сервер та бути прийнятими. Сервер прив'язується до вказаної IP-адреси та порту і запускається в асинхронному режимі, забезпечуючи можливість обробки одночасних запитів від клієнтів.
Тестування проводилося вручну за допомогою Swagger. Використання Swagger зробило процес тестування швидким і зручним, а також дозволило значно зекономити час, який інакше був би витрачений на написання тестів або виклики методів через термінал. Функціональне тестування полягало в надсиланні HTTP-запитів з різними наборами даних на сервер та виклику методів, зареєстрованих за вказаними в запитах адресами.
Для розуміння логіки та архітектури системи розглянемо структуру сервісу «SheepService», оскількі він має найбільше функціоналу, та імплементацію методів трейтів «Service» та «SheepManage» (див. Додаток А пункт А.2). Структура «SheepService» містить поле для, яке повинно надавати зв’язок до каналу отримання даних. Тип цього поле не визначений, тому цей сервіс може підтримувати будь-яку реалізацію. В даному випадку використовується пул зв’язку з базою даних MySQL. Ця структура була створена, щоб інкапсулювати бізнес логіку у методі, до яких буде можливо звернутись через цю структуру. 	Цей патерн проектування називається Service Layer. Цей патерн допомагає створювати добре структуровані, підтримувані та масштабовані додатки з чітким розділенням бізнес-логіки від інших частин системи.
Перший трейт, який імплементує «SheepService» це «Service». Цей трейт є базовим для всіх сервісів, тому його імплементують всі сервіси. Для його імплементації потрібно реалізувати методи: «new», «create», «delete», «update», «get_all», «get_by_id». Метод «new» створює новий екземпляр сервісу з переданим пулом з'єднань; метод «create» відповідає за створення нової вівці у базі даних; метод «delete» видаляє вівцю за її ідентифікатором; метод «update» оновлює інформацію про вівцю; метод «get_all» отримує всі овець; метод «get_by_id» отримує вівцю за її ідентифікатором.
Також для імплементації трейту «Service» потрібно визначити асоційовані типи, а саме «Model» — модель з якою будуть працювати методи, «Error» — помилка яку будуть повертати методи, «ViewModel» — модель представлення яку будуть повертати методи. В цій імплементації ці типи визначено як: «Model» — «Sheep», «Error» — «ServiceError», «ViewModel» — «SheepVM». «Sheep» це структура, яка  представляє сутність вівці з бази даних, та містить ідентичні з нею поля. «SheepVM» це модель представлення вівці, вона містить id вівці, назву породи, стать, дату народження та дати останніх стрижки та годування. «ServiceError» це перерахування, яке представляю собою типи помилок, до яких приводяться всі помилки, які можуть виникнути при роботі програмі.
Другий трейт, який імплементує «SheepService», це «SheepManage», який є розширенням для трейту «Service». Тобто імплементація «SheepManage» неможлива без «Service». Це дає змогу використовувати асоційовані типи з «Service» у «SheepManage». Цей трейт спеціалізується на управлінні даними, пов'язаними з вівцями, і додає додаткові методи, специфічні для цього сервісу. 	Для його імплементації потрібно реалізувати методи: «get_all_vms_by_shepherd_id», «get_details_by_id», «change_shepherd», «change_temperature_scanner». Метод «get_all_vms_by_shepherd_id» отримує всі моделі представлення овець за ідентифікатором пастуха; метод «get_details_by_id» отримує детальну інформацію про вівцю за її ідентифікатором; метод «change_shepherd» змінює пастуха для вівці; метод «change_temperature_scanner» змінює сканер температури для вівці. 
Також для імплементації трейту «SheepManage» потрібно визначити асоційовані типи, а саме «SheepDetails» — структура, з якою буде працювати метод «get_details_by_id». В цій імплементації ці типи визначено як: «SheepDetails» — «SheepDetailsVM». «SheepDetailsVM» це структура, яка  містить в собі детальну інформацію про вівцю. 
Розглянемо ендпоінти з підмодуля sheep_endpoints.rs модулю endpoints (див. Додаток А пункт А.3). Цей модуль містить в собі тільки методи, які мають в аргументах об’єкт типу «SheepService». Деякі методи також приймають моделі або JSON структури для отримання тіла запиту або параметрів. Кожен з цих методів викликає за допомогою сервісу один з методів реалізованих цим сервісом, а потім повертає результат його роботи клієнту. 
Метод «sheep_get_all» очікує HTTP GET запити за адресою /sheep і використовує метод «get_all()» сервісу для отримання всіх овець із бази даних. 	Метод «sheep_get_by_id» очікує HTTP GET запити за адресою /sheep/{id} і використовує метод «get_by_id()» сервісу для отримання вівці за її ID, який передається в шляху запиту. Метод «sheep_get_details_by_id» очікує HTTP GET запити за адресою /sheep/details/{id} і використовує метод «get_details_by_id()» сервісу для отримання детальної інформації про вівцю за її ID. Метод «sheep_get_all_vms_by_shepherd_id» очікує HTTP GET запити за адресою /sheep/shepherd/{id} і використовує метод «get_all_vms_by_shepherd_id()» сервісу для отримання всіх моделей представлення овець за ідентифікатором пастуха.
Метод «sheep_create» очікує HTTP POST запити за адресою /sheep/create і використовує метод «create()» сервісу, отримуючи дані для створення нової вівці у тілі запиту. Метод «sheep_update» очікує HTTP PUT запити за адресою /sheep/update і використовує метод «update()» сервісу, отримуючи дані для оновлення інформації про вівцю у тілі запиту. Метод «sheep_change_shepherd» очікує HTTP PATCH запити за адресою /sheep/change-shepherd/{id} і використовує метод «change_shepherd()» сервісу, отримуючи ідентифікатор нового пастуха для зміни у тілі запиту та ідентифікатор вівці в шляху запиту. Метод «sheep_change_temperature_scanner» очікує HTTP PATCH запити за адресою /sheep/change-temperature-scanner/{id} і використовує метод «change_temperature_scanner()» сервісу, отримуючи ідентифікатор нового сканера температури для зміни у тілі запиту та ідентифікатор вівці в шляху запиту. Метод «sheep_delete» очікує HTTP DELETE запити за адресою /sheep/delete/{id} і використовує метод «delete()» сервісу, отримуючи ID вівці для видалення в шляху запиту. 
Для валідації тіла запиту, логування та надсилання відповіді ендпоінти використовують функції за підмодуля utils.rs модуля endpoints (див. Додаток А пункт А.4). Цей модуль містить функції «validate_json_body», «send_service_result», «send_service_message». Функція «validate_json_body» відповідає за валідацію JSON тіла запиту. Якщо валідація проходить успішно, функція повертає структуру, перетворену з JSON. У випадку помилки валідації функція повертає HTTP відповідь із статусом BadRequest та повідомленням про помилку. Це дозволяє забезпечити, що всі дані, які надходять у запитах, відповідають вимогам і можуть бути безпечно оброблені далі.
Функція «send_service_result» використовується для надсилання результату роботи сервісу. У випадку успішного виконання функція повертає HTTP відповідь із статусом Ok та результатом у форматі JSON. Якщо виникає помилка, функція повертає HTTP відповідь із статусом InternalServerError та повідомленням про помилку. Це дозволяє централізовано обробляти результати виконання сервісних методів і повертати відповідні відповіді клієнтам.
Функція «send_service_message» призначена для надсилання повідомлень про результат роботи сервісу. У випадку успішного виконання функція повертає HTTP відповідь із статусом Ok та повідомленням у форматі JSON. Якщо виникає помилка, функція повертає HTTP відповідь із статусом InternalServerError та повідомленням про помилку. Це забезпечує єдиний підхід до надсилання повідомлень про результат виконання дій, що підвищує зручність налагодження та підтримки коду.
Розглянемо функцію конфігурацію «sheep_configure» з підмодуля configure.rs модулю configs (див. Додаток А пункт А.5). Виклик цієї функції в методі main реєструє всі ендпоінти з модуля sheep_endpoints.rs та робить їх доступними за вказаними адресами. 
Розгляд інших 8 сервісів не є необхідним оскільки вони реалізовані за тією ж архітектурою. Кожен сервіс імплементує трейт «Service» та має свій трейт для специфічних методів. Також для кожного сервісу є відповідний підмодуль у модулі endpoints та функція конфігурації в модулі configure.rs. 

5.2 IoT частина


Для реалізації IoT частини була обрана мова програмування Rust. Ця мова була обрана через те, що вона, як і мова програмування C, напряму підтримує розробку програмного забезпечення для пристроїв без операційних систем та вбудованих девайсів. Так як популярні редактори для емуляції та будування схем Embedded пристроїв на момент розробки не підтримують можливість писати та запускати код на Rust, а при розробці не було доступу до пристрою температурного сканера і можливості тестувати на ньому код, то було прийнято рішення земулювати температурний сканер, використовуючи асинхронний runtime tokio та стандартну бібліотеку. IoT пристрій використовує HTTP протокол для передачі даних для зв’язку із серверною частиною. 
Для визначення та моделювання функціоналу IoT частини побудуємо діаграму діяльності та діаграму взаємодії (див. рисунки 5.1 та 5.1). На цих діаграмах детально представлено послідовність дій та взаємодій IoT пристрою протягом його життєвого циклу, починаючи з моменту запуску і завершуючи його вимкненням.
Діаграми надають вичерпний огляд процесів автентифікації, обміну даними з сервером, а також відповідні дії при отриманні та обробці інформації. Це дозволяє чітко зрозуміти усі етапи роботи пристрою та забезпечує основу для подальшого розвитку та оптимізації системи.


Рисунок 5.1 – Діаграма діяльності


Рисунок 5.2 – Діаграма взаємодії

Реалізація емуляції IoT частини системи управління температурним сканером передбачає за допомогою мови Rust передбачає побудову архітектури, яка у разі необхідності зможе бути легко змінена та адаптована до вбудованих пристроїв і може бути переписана без використання стандартної бібліотеки.	Робота програми відбувається у методі main (див. Додаток Б пункт Б.1), на початку роботи якого відбувається отримання URL сервера зі змінної середовища виконується за допомогою, де у разі помилки викликається спеціально розроблена функція з модуля utils.rs (див. Додаток Б пункт Б.2) — panic(), яка припиняє роботу програми з відповідним повідомленням шляхом запуску нескінченого циклу. Це важливо для забезпечення надійності системи, оскільки без правильного URL серверу подальша робота є неможливою.
Перед початком роботи сканера відбувається аутентифікація на сервері. Для цього зчитуються та форматуються аргументи командного рядка за допомогою функції з модуля auth.rs (див. Додаток Б пункт Б.3) read_and_format_cli_arguments(). Введені користувачем дані (ідентифікатор сканера та пароль) перевіряються на коректність та формуються у структуру TemperatureScannerAuthJson.
Процес аутентифікації реалізовано у функції authenticate() з модуля auth.rs, яка надсилає HTTP POST-запит на сервер для перевірки автентичності сканера. У разі успішної аутентифікації програма продовжує роботу, в іншому випадку викликається функція panic().
Основний цикл програми реалізовано у вигляді нескінченного циклу, який зчитує температуру та надсилає її на сервер через фіксовані інтервали часу. Початкова температура встановлюється на рівні 370 (у сотих долях градуса), що дозволяє моделювати реальні умови роботи сканера.
Зчитування температури виконується функцією read_temperature() з модуля temperature.rs (див. Додаток Б пункт Б.4), яка генерує нове значення температури в межах заданих мінімальних і максимальних значень. Для цього використовується генератор випадкових чисел, що додає випадкове значення до попередньої температури, забезпечуючи природну варіацію даних.
Передача температури на сервер здійснюється функцією send_temperature() з модуля temperature.rs, яка формує та надсилає HTTP PATCH-запит до сервера. Відповідь сервера обробляється для визначення успішності операції. У разі успіху програма робить затримку на 5 секунд перед наступним циклом, в іншому випадку відображається повідомлення про помилку і користувачеві пропонується самостійно запустити цикл далі за допомогою функції continue_action() з модуля utils.rs.
Обробка помилок в системі реалізована за допомогою спеціального перерахування ScannerError з модуля scanner_error.rs (див. Додаток Б пункт Б.5), яке описує різні типи можливих помилок (помилки аргументів, оновлення температури, аутентифікації). Для кожного типу помилки реалізовано форматування повідомлень, що забезпечує зручне відображення інформації для користувача.
Функція panic() використовується для завершення програми у разі критичних помилок, таких як невірні змінні середовища або невдала аутентифікація. Вона відображає повідомлення про помилку і зупиняє програму, що дозволяє уникнути некоректної роботи системи.
Функція display() з модуля utils.rs використовується для виведення всіх повідомлень, які може надсилати пристрій.
Таким чином, реалізація IoT частини системи забезпечує ефективний збір, обробку та передачу даних про температуру, що є важливим для догляду за вівцями.

5.3 Веб-клієнт


Клієнтська частина має архітектуру, яка використовує React [4] та TypeScript [5] як основний фронтенд фреймворк, що забезпечує всі необхідні інструменти та можливості для створення клієнтських додатків. Для взаємодії з сервером будуть застосовуватись HTTP-методи, які направлятимуться на адресу REST API та міститимуть маршрут до відповідного методу.
React заснований на концепції компонентів, що дає змогу створювати веб-інтерфейс із невеликих, повторно використовуваних елементів. Це значно спрощує розробку та підтримку великих проектів. Крім того, React використовує віртуальний DOM для ефективного оновлення відображення при зміні даних, що робить додаток більш продуктивним і швидкодійним. 	Використання віртуального DOM є ключовою особливістю React, оскільки це робить його ідеальним вибором для створення SPA, де весь контент завантажується одноразово під час запуску додатка, а подальша навігація здійснюється без повторного завантаження сторінок. React має найбільшу та найрозвиненішу екосистему серед усіх наявних фронтенд фреймворків на сьогодні. Поєднання всіх цих факторів робить React дуже ефективним рішенням для створення клієнтських веб-додатків.
Веб-клієнт надає весь необхідний функціонал, що потрібний для користування програмною системою для контролю роботи вовняної ферми.
При запуску додатку користувачу необхідно авторизуватись для отримання доступу до основного функціоналу. Під час авторизації користувач зможе обрати під якою роллю йому користуватись системою.
Якщо користувач авторизувався як вівчар, він відразу потрапляє на головну сторінку вівчаря. Після авторизації йому постійно доступні функції виходу з акаунту. На головній сторінці розташоване меню з трьома кнопками, які змінюють контент на головній сторінці за вибором вівчаря. Перша кнопка за замовчуванням активна і відображає під панеллю список овець, за якими він доглядає, а також основну інформацію про них. Друга кнопка показує список порід овець, які є на фермі, та інформацію про кожну породу. Третя кнопка демонструє список кормів, доступних на фермі, та інформацію про них. При натисканні на вівцю зі списку, вівчар перейде на сторінку з деталями про вівцю. На сторінці з деталями розташоване меню з трьома кнопками, які змінюють контент на сторінці з деталями за вибором вівчаря. Перша кнопка за замовчуванням активна і відображає під панеллю детальну інформацію про вівцю включаючи її номер, температуру, дати останніх годування та стрижки, породу та інформацію про неї, вік у днях та інше. Також поруч з датами про годування та стрижки вівчар зможе зробити відмітки про проведені стрижку або годування. Друга кнопка показує список з відмітками про годування цієї вівці та інформацію про них. Третя кнопка показує список з відмітками про стрижку цієї вівці та інформацію про них.
Діаграма станів, яка показує взаємодію вівчаря з веб-клієнтом наведена на рисунку 5.3.
Якщо користувач авторизувався як комірник, він відразу потрапляє на головну сторінку комірника. Після авторизації йому постійно доступні функції виходу з акаунту. На головній сторінці розташований список кормів, які є на фермі та інформація про них. На кожній картці корму розташована кнопка, яка відкриває форму для додавання нової поставки корму. При натисканні на корм зі списку, комірник перейде на сторінку корму. На сторінці корму розташоване меню з двома кнопками, які змінюють контент на сторінці корму за вибором вівчаря. Перша кнопка за замовчуванням активна і відображає під панеллю список поставок обраного корму, а також основну інформацію про них. Друга кнопка показує список годувань обраним кормом та інформацію них.
Діаграма станів, яка показує взаємодію комірника з веб-клієнтом наведена на рисунку 5.4.


Рисунок 5.3 – Діаграма станів для вівчаря


Рисунок 5.4 – Діаграма станів для  комірника

Якщо користувач авторизувався як фермер, він відразу потрапляє на головну сторінку фермера. Після авторизації йому постійно доступні функції виходу з акаунту. На головній сторінці розташоване меню з дев’ятьма кнопками, яке дозволяє перемикати контент на головній сторінці за вибором фермера.   	Перша кнопка відображає таблицю з переліком вівчарів, які працюють на фермі. Під таблицею розташовані кнопки для додавання, зміни та видалення записів. Кнопка "Додати" доступна завжди, а кнопки "Змінити" та "Видалити" стають доступними тільки після вибору конкретного запису.
Друга кнопка відображає таблицю з переліком комірників. Під цією таблицею також є кнопки для додавання, зміни та видалення записів, де кнопка "Додати" доступна завжди, а "Змінити" та "Видалити" - лише при виборі запису.
Третя кнопка перемикає вміст на таблицю з переліком овець. Як і в попередніх випадках, під таблицею розташовані кнопки для додавання, зміни та видалення записів. Кнопка "Додати" доступна завжди, а кнопки "Змінити" та "Видалити" - тільки при виборі конкретного запису, а також дві додаткові кнопки для перепризначення вівчаря та перепризначення сканера температури. Кнопка "Перепризначити вівчаря" перенаправляє на сторінку перепризначення вівчаря для вибраної вівці. На цій сторінці знаходиться форма із номером вівці та випадаючим списком вівчарів. Після вибору потрібного вівчаря можна натиснути кнопку "Перепризначити", яка виконає зміну та поверне на головну сторінку фермера. Кнопка "Перепризначити сканер температури" перенаправляє на сторінку перепризначення сканера температури для вибраної вівці. На цій сторінці знаходиться форма із номером вівці та випадаючим списком вільних сканерів температури. Після вибору потрібного сканера можна натиснути кнопку "Перепризначити", яка виконає зміну та поверне на головну сторінку фермера.
Четверта кнопка відображає таблицю з переліком сканерів температури. Під таблицею також знаходяться кнопки для додавання, зміни та видалення записів. Кнопка "Додати" завжди доступна, а кнопки "Змінити" та "Видалити" стають доступними тільки після вибору запису.
П'ята кнопка показує таблицю з переліком порід овець. Під таблицею розташовані кнопки для додавання, зміни та видалення записів. Кнопка "Додати" завжди доступна, а кнопки "Змінити" та "Видалити" стають доступними лише після вибору конкретного запису.
Шоста кнопка перемикає вміст на таблицю з переліком кормів. Під таблицею знаходяться кнопки для додавання, зміни та видалення записів. Кнопка "Додати" завжди доступна, а кнопки "Змінити" та "Видалити" стають доступними лише при виборі запису.
Сьома кнопка відображає таблицю з переліком записів про годування. Під цією таблицею знаходиться лише кнопка для видалення записів, яка стає доступною тільки після вибору конкретного запису.
Восьма кнопка показує таблицю з переліком записів про стрижку. Під таблицею розташована тільки кнопка для видалення записів, яка стає доступною після вибору конкретного запису.
Дев'ята кнопка відображає таблицю з переліком поставок корму. Під цією таблицею знаходиться лише кнопка для видалення записів, яка стає доступною після вибору конкретного запису.
Натискання кнопок "Додати" та "Змінити" перенаправляє на сторінку з формою для створення або редагування запису. У формі для додавання поля будуть порожніми, і після їх заповнення фермер може натиснути кнопку "Додати", щоб створити новий запис. Після цього він буде повернений на головну сторінку фермера. У формі для редагування поля будуть заповнені обраним із таблиці записом. Після внесення змін фермер може натиснути кнопку "Змінити", і після збереження змін він буде повернений на головну сторінку фермера. Після натискання кнопки "Видалити" запис буде видалений з таблиці та бази даних. 
Діаграма станів, яка показує взаємодію фермера з веб-клієнтом наведена на рисунку 5.5.


Рисунок 5.5 – Діаграма станів для  фермера

Реалізація веб-клієнта починається з файлу main.tsx. В ньому створюється об'єкт resources, який містить переклади для англійської та української мов. Потім ініціалізується i18next з використанням initReactI18next для інтеграції з React. Налаштовуються ресурси для перекладів, встановлюється мова за замовчуванням (українська) та резервна мова (також українська), а також вимикається escaping для безпеки. Після цього викликається ReactDOM.createRoot для рендерингу кореневого компонента Router у DOM елемент з ідентифікатором root.
Компонент Router (див. Додаток В пункт В.1) відповідає за маршрутизацію застосунку та управління станом авторизації користувача. Використовується стан для зберігання авторизованого користувача, а також функція для виходу з акаунту, яка оновлює стан і зберігає неавторизованого користувача в Local Storage. При завантаженні компонента виконується useEffect для завантаження користувача з Local Storage. Для багатомовності використовується i18n, а функція changeLanguage дозволяє змінювати мову інтерфейсу. Маршрутизація здійснюється за допомогою BrowserRouter, Routes та Route, забезпечуючи навігацію між різними сторінками застосунку. Додаються різні маршрути для сторінок, таких як головна сторінка, сторінки з інформацією про овець, корми, пастухів, комірників та інші.
Компонент App.tsx відповідає за рендеринг головної сторінки залежно від ролі користувача. Використовується React.FC для визначення типу компонента, а також властивості user та setUser. Виклик useEffectUser забезпечує навігацію на відповідні сторінки залежно від ролі користувача. Компонент рендерить різні підкомпоненти залежно від ролі користувача: AuthorizationForm для неавторизованих користувачів, ShepherdMainPage для пастухів, StorekeeperMainPage для комірників та AdminMainPage для фермерів.  Сторінка  AuthorizationForm надає можливість зареєструватись, а сторінки  ShepherdMainPage,  StorekeeperMainPage та  AdminMainPage надають доступ своїм типам користувачам до функціоналу описаного в попередньому розділі.
Для розуміння логіки та архітектури системи розглянемо структуру сервісу «SheepService» (див. Додаток В пункт В.2), оскільки він має найбільше функціоналу, та імплементацію методів інтерфейсів «IService» та «ISheepService». Структура «SheepService» містить статичні URL-адреси для запитів до API, які забезпечують зв’язок з бекендом. Ця структура була створена для інкапсуляції бізнес-логіки у методах, до яких можливо звернутись через цю структуру. Цей патерн проектування називається Service Layer. Цей патерн допомагає створювати добре структуровані, підтримувані та масштабовані додатки з чітким розділенням бізнес-логіки від інших частин системи.
Перший інтерфейс, який реалізує «SheepService», це «IService». Цей інтерфейс є базовим для всіх сервісів, тому його реалізують всі сервіси. Для його реалізації потрібно визначити методи: create, delete, update, getAll, getById. Метод create відповідає за створення нової вівці за допомогою POST-запиту до API; метод delete видаляє вівцю за її ідентифікатором за допомогою DELETE-запиту; метод update оновлює інформацію про вівцю за допомогою PUT-запиту; метод getAll отримує всіх овець за допомогою GET-запиту; метод getById отримує вівцю за її ідентифікатором за допомогою GET-запиту.
Також для реалізації інтерфейсу «IService» потрібно визначити асоційовані типи, а саме Model та ViewModel. В цій реалізації ці типи визначено як: Model — Sheep, ViewModel — SheepVM. Sheep це клас, який представляє сутність вівці з такими полями, як ідентифікатор, дата народження, ідентифікатор породи, вага, стать, ідентифікатор температурного сканера та пастуха. SheepVM це клас для відображення інформації про вівцю, який містить ідентифікатор, породу, стать, дату народження, дати останнього годування та стрижки.
Другий інтерфейс, який реалізує «SheepService», це «ISheepService», який є розширенням для інтерфейсу «IService». Тобто реалізація «ISheepService» неможлива без «IService». Це дає змогу використовувати асоційовані типи з «IService» у «ISheepService». Цей інтерфейс спеціалізується на управлінні даними, пов'язаними з вівцями, і додає додаткові методи, специфічні для цього сервісу. Для його реалізації потрібно визначити методи: getAllVMsByShepherdId, getDetailsById, changeShepherd, changeTemperatureScanner. Метод getAllVMsByShepherdId отримує всі моделі представлення овець за ідентифікатором пастуха за допомогою GET-запиту; метод getDetailsById отримує детальну інформацію про вівцю за її ідентифікатором за допомогою GET-запиту; метод changeShepherd змінює пастуха для вівці за допомогою PATCH-запиту; метод changeTemperatureScanner змінює сканер температури для вівці за допомогою PATCH-запиту.
Також для реалізації інтерфейсу «ISheepService» потрібно визначити асоційований тип DetailsViewModel. В цій реалізації цей тип визначено як SheepDetailsVM. SheepDetailsVM це клас, який містить детальну інформацію про вівцю, включаючи такі поля, як ідентифікатор, порода, інформація про породу, стать, вік, дати останнього годування та стрижки, вага, температура, ідентифікатор та назва корму, необхідна та доступна кількість корму, а також індикатори необхідності годування та стрижки.
Для відправлення запитів було прийнято рішення використовувати пакет axios оскільки він є зручнішою версією fetch.  
Розгляд інших 8 сервісів не є необхідним оскільки вони реалізовані за тією ж архітектурою. Кожен сервіс імплементує інтерфейс «IService» та має свій інтерфейс для специфічних методів. 
Також розглянемо модуль «helpers.ts» (див. Додаток В пункт В.3), який містить різноманітні допоміжні функції, що використовуються у фронтенд застосунку.
Функція timestampToDate призначена для конвертації мітки часу в дату у форматі "гг:хх дд.мм.рррр". Ця функція отримує мітку часу у секундах, створює новий об'єкт Date, витягує години, хвилини, день, місяць та рік з цього об'єкту, а потім форматує їх у вказаний формат.
Функція saveAuthUserToLocalStorage використовується для збереження авторизованого користувача в Local Storage. Вона приймає ключ і об'єкт користувача, серіалізує цей об'єкт у JSON і зберігає його в Local Storage під заданим ключем. У разі виникнення помилки, вона виводить повідомлення про помилку у консоль.
Функція getAuthUserFromLocalStorage призначена для отримання авторизованого користувача з Local Storage. Вона приймає ключ, зчитує збережений JSON, десеріалізує його та повертає об'єкт AuthUser. Якщо збережене значення не знайдено або виникає помилка, повертається об'єкт з неавторизованим користувачем.
Функція hashPassword використовується для хешування пароля. Вона приймає пароль, перетворює його у масив байтів, обчислює його SHA-256 хеш і повертає його у вигляді шестнадцяткового рядка.
Хук useEffectUser виконується при завантаженні компонента та перевіряє, чи авторизований користувач збережений у Local Storage. Якщо користувач не авторизований, він перенаправляє користувача на головну сторінку.
Функція handleElementChange обробляє зміну елементів форми. Вона приймає подію зміни елементу та функцію для оновлення стану, витягує значення з події та оновлює стан.
Функція timeInDays обчислює час у днях з мітки часу. Вона приймає мітку часу, обчислює різницю між поточним часом і переданою міткою, перетворює цю різницю у дні та повертає кількість днів.

6 ОСОБЛИВОСТІ ВИКОРИСТАННЯ


Розроблена система для контролю роботи вовняної ферми має широкий спектр застосування та може бути адаптована до різних умов і потреб фермерських господарств. Завдяки своїй гнучкості та масштабованості, система забезпечує ефективний моніторинг і управління всіма аспектами діяльності ферми.
Малі та середні ферми можуть використовувати систему для автоматизації основних процесів, що значно зменшує обсяг ручної праці та мінімізує помилки, спричинені людським фактором. Впровадження системи дозволяє фермерам відстежувати здоров'я овець у реальному часі за допомогою IoT-сенсорів, що вимірюють температуру тварин, оптимізувати графіки годування та стрижки, забезпечуючи належні умови утримання та підвищуючи продуктивність тварин, а також управляти обліком кормів та інших ресурсів, що дозволяє ефективно планувати закупівлі та витрати.
Великі ферми зможуть використовувати систему для підвищення продуктивності та рентабельності. Система забезпечує масштабованість, дозволяючи одночасно обробляти дані від великої кількості тварин та користувачів без втрати продуктивності. Зручний доступ до даних через веб-клієнт та мобільний додаток дозволяє фермерам і працівникам швидко отримувати необхідну інформацію та приймати обґрунтовані рішення. Автоматизація процесів зменшує час на виконання рутинних завдань, таких як ведення обліку та складання звітів.
Однією з ключових особливостей використання системи є забезпечення стабільної комунікації між усіма компонентами – сервером, IoT-пристроями та клієнтськими додатками. Це досягається завдяки чітко визначеним API, що дозволяють легко інтегрувати різні компоненти системи та забезпечувати їхню сумісність. Система вимагає стабільного інтернет-з'єднання для безперебійного обміну даними та надійної роботи всіх її компонентів. Інтерфейс веб-клієнту наведений у додатку Г (див. рисунки Г.1 — Г.5).
Таким чином, розроблена система для контролю роботи вовняної ферми забезпечує значні переваги для фермерських господарств різного масштабу, підвищуючи їхню продуктивність, знижуючи витрати та покращуючи якість продукції.

ВИСНОВКИ


У рамках цієї курсової роботи було розроблено та впроваджено систему для контролю роботи вовняної ферми, що складається з чотирьох основних компонентів: серверної частини, IoT-сенсорів, веб-клієнта та мобільного додатку. Кожен із компонентів виконує специфічні функції, спрямовані на забезпечення ефективного управління, моніторингу та оптимізації процесів на фермі.
Серверна частина системи, розроблена з використанням мови програмування Rust та фреймворку Actix Web, забезпечує надійне зберігання та обробку даних у базі даних MySQL. Це дозволяє здійснювати CRUD операції над об'єктами системи, такими як вівці, породи, корма, вівчарі, комірники, поставки кормів, температурні сканери, графіки годування та стрижки. Надійне зберігання даних є ключовим для забезпечення гнучкості та функціональності системи.
Веб-клієнт, реалізований на основі React, надає користувачам зручний та інтуїтивно зрозумілий інтерфейс для управління фермою. Користувачі можуть легко здійснювати моніторинг стану овець, кормів, а також робити записи про свої дії.
Мобільний додаток на базі Kotlin забезпечує доступ до системи з мобільних пристроїв, дозволяючи фермерам отримувати інформацію про стан овець, графіки годування та стрижки, а також здійснювати необхідні коригування та записи безпосередньо на місці.
IoT-сенсори забезпечують збір, обробку та передачу даних про температуру овець у реальному часі. Дані передаються до серверної частини системи, де вони зберігаються та аналізуються для оптимізації процесів догляду за тваринами. Це дозволяє враховувати стан здоров'я овець та здійснювати відповідні коригування у режимі реального часу.
Завдяки інтеграції цих чотирьох компонентів система для контролю роботи вовняної ферми забезпечує комплексний підхід до управління фермерським господарством. Вона дозволяє знижувати витрати на ручну працю, підвищувати ефективність використання ресурсів та покращувати якість продукції.
Розроблена система може бути успішно застосована як у малих і середніх фермерських господарствах, так і у великих комерційних підприємствах. Вона відкриває широкі можливості для оптимізації виробничих процесів та підвищення продуктивності.
У подальшому можливим є розширення функціональних можливостей системи, включення додаткових типів сенсорів для моніторингу інших параметрів здоров'я тварин, а також інтеграція з іншими системами управління фермерськими господарствами. Це дозволить зробити систему ще більш ефективною та адаптивною до потреб різних користувачів.
Таким чином, розроблена система для контролю роботи вовняної ферми є важливим інструментом для підвищення ефективності управління фермерськими господарствами, зниження витрат та покращення якості продукції. Вона відкриває широкі можливості для подальшого розвитку та впровадження сучасних технологій в аграрну сферу, сприяючи підвищенню рентабельності та стійкості фермерських господарств.

ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ


1. Rust Foundation. The Rust Programming Language [Електронний ресурс]: https://doc.rust-lang.org/book/. (дата звернення 01.05.2024)
2. Actix. Actix Web Documentation [Електронний ресурс]: https://actix.rs. (дата звернення 01.05.2024)
3. Vite. Vite Guide [Електронний ресурс]: https://vitejs.dev/guide/. (дата звернення 01.05.2024)
4. React. React Documentation [Електронний ресурс]: https://reactjs.org/docs/getting-started.html. (дата звернення 01.05.2024)
5. TypeScript. TypeScript Documentation [Електронний ресурс]: https://www.typescriptlang.org/docs/. (дата звернення 01.05.2024)

ДОДАТОК А
Код реалізації логіки сервера

А.1 Файл main.rs


 1  #[main]
 2  async fn main() -> io::Result<()>{
 3      // Завантаження змінних середовища
 4      dotenv().ok();
 5  
 6      // Отримання IP-адреси додатку зі змінної середовища
 7      let app_ip_bytes: Vec<u8> = env::var("APP_IP").unwrap_or_else(|_| "".to_string())
 8          .split('.')
 9          .map(|byte| byte.parse::<u8>().expect("Invalid number in APP_IP"))
10          .collect();
11      let app_ip: Ipv4Addr = Ipv4Addr::new(app_ip_bytes[0], app_ip_bytes[1], app_ip_bytes[2], app_ip_bytes[3]);
12  
13      // Отримання порту додатку зі змінної середовища
14      let app_port: u16 = env::var("APP_PORT").unwrap_or_else(|_| "".to_string())
15          .parse().expect("Invalid app port number");
16  
17      // Отримання рядка підключення до бази даних зі змінної середовища
18      let db_string = env::var("DATABASE_URL").unwrap_or_else(|_| "".to_string());
19  
20      // Створення контексту бази даних
21      let db_context: DbContextMySql<Pool<MySql>> = DbContextMySql::new(db_string).await;
22  
23      // Створення сервісів
24      let breed_service: Arc<BreedService<Pool<MySql>>> = Arc::new(BreedService::new(db_context.get_pool()));
25      let feed_service: Arc<FeedService<Pool<MySql>>> = Arc::new(FeedService::new(db_context.get_pool()));
26      let feed_supply_service: Arc<FeedSupplyService<Pool<MySql>>> = Arc::new(FeedSupplyService::new(db_context.get_pool()));
27      let feeding_log_service: Arc<FeedingLogService<Pool<MySql>>> = Arc::new(FeedingLogService::new(db_context.get_pool()));
28      let shearing_log_service: Arc<ShearingLogService<Pool<MySql>>> = Arc::new(ShearingLogService::new(db_context.get_pool()));
29      let sheep_service: Arc<SheepService<Pool<MySql>>> = Arc::new(SheepService::new(db_context.get_pool()));
30      let shepherd_service: Arc<ShepherdService<Pool<MySql>>> = Arc::new(ShepherdService::new(db_context.get_pool()));
31      let storekeeper_service: Arc<StorekeeperService<Pool<MySql>>> = Arc::new(StorekeeperService::new(db_context.get_pool()));
32      let temperature_service: Arc<TemperatureScannerService<Pool<MySql>>> = Arc::new(TemperatureScannerService::new(db_context.get_pool()));
33  
34      // Налаштування логування
35      LoggerWrapper::default();
36      info!("Server started");
37  
38      // Налаштування та запуск HTTP сервера
39      HttpServer::new(move || {
40          App::new()
41              .app_data(Data::new(breed_service.clone()))
42              .app_data(Data::new(feed_service.clone()))
43              .app_data(Data::new(feed_supply_service.clone()))
44              .app_data(Data::new(feeding_log_service.clone()))
45              .app_data(Data::new(shearing_log_service.clone()))
46              .app_data(Data::new(sheep_service.clone()))
47              .app_data(Data::new(shepherd_service.clone()))
48              .app_data(Data::new(storekeeper_service.clone()))
49              .app_data(Data::new(temperature_service.clone()))
50              .wrap(
51                  Cors::default()
52                      .allow_any_origin()
53                      .allowed_methods(vec!["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"])
54                      .allowed_headers(vec![header::AUTHORIZATION, header::ACCEPT, header::ACCESS_CONTROL_REQUEST_METHOD, header::ACCESS_CONTROL_REQUEST_HEADERS, header::ORIGIN, header::CONTENT_TYPE])
55                      .max_age(3600)
56              )
57              .wrap(Logger::default())
58              .configure(breed_configure)
59              .configure(feed_configure)
60              .configure(feed_supply_configure)
61              .configure(feeding_log_configure)
62              .configure(shearing_log_configure)
63              .configure(sheep_configure)
64              .configure(shepherd_configure)
65              .configure(storekeeper_configure)
66              .configure(temperature_scanner_configure)
67              .service(SwaggerUiWrapper::build_swagger_ui())
68      }).bind((app_ip, app_port))?.run().await
69  }
	
А.2 Модуль sheep_service.rs


 1  // Сервіс для управління вівцями
 2  pub(crate) struct SheepService<T>{
 3      pool: Arc<T>,
 4  }
 5  
 6  #[async_trait]
 7  impl Service<Pool<MySql>> for SheepService<Pool<MySql>> {
 8      type Model = Sheep;
 9      type Error = ServiceError;
10      type ViewModel = SheepVM;
11  
12      fn new(pool: Arc<Pool<MySql>>) -> Self {
13          SheepService { pool }
14      }
15  
16      // Функція для створення нової вівці
17      async fn create(&self, mut item: Self::Model) -> Result<Self::Model, Self::Error> {
18          query(
19              r#"
20              INSERT INTO Sheep (birth_date, breed_id, weight, sex, temperature_scanner_id, shepherd_id)
21              VALUES (?, ?, ?, ?, null, ?)
22              "#
23          )
24              .bind(item.birth_date())
25              .bind(item.breed_id())
26              .bind(item.weight())
27              .bind(item.sex())
28              .bind(item.shepherd_id())
29              .execute(&*self.pool).await
30              .map_err(|error| ServiceError::DatabaseError(error))
31              .map(|result|
32                  if result.rows_affected() == 1 {
33                      item.set_id(result.last_insert_id());
34                      Ok(item)
35                  }
36                  else{
37                      Err(ServiceError::CustomError("Insertion went wrong. Zero rows affected".to_string()))
38                  }
39              )
40              .unwrap_or_else(|error| Err(error))
41      }
42  
43      // Функція для видалення вівці за її ідентифікатором
44      async fn delete(&self, item_id: u64) -> Result<(), Self::Error> {
45          query(
46              r#"
47              DELETE FROM Sheep
48              WHERE id = ?
49              "#
50          )
51              .bind(item_id)
52              .execute(&*self.pool).await
53              .map_err(|error| ServiceError::DatabaseError(error))
54              .map(|result|
55                  if result.rows_affected() == 0 {
56                      Err(ServiceError::CustomError("Zero rows affected".to_string()))
57                  }
58                  else{
59                      Ok(())
60                  }
61              )
62              .unwrap_or_else(|error| Err(error))
63      }
64  
65      // Функція для оновлення інформації про вівцю
66      async fn update(&self, item: Self::Model) -> Result<Self::Model, Self::Error> {
67          query(
68              r#"
69              UPDATE Sheep
70              SET birth_date = ?, breed_id = ?, weight = ?, sex = ?, temperature_scanner_id = ?, shepherd_id = ?
71              WHERE id = ?
72              "#
73          )
74              .bind(item.birth_date())
75              .bind(item.breed_id())
76              .bind(item.weight())
77              .bind(item.sex())
78              .bind(item.temperature_scanner_id())
79              .bind(item.shepherd_id())
80              .bind(item.id().ok_or(ServiceError::CustomError("ID is required".to_string()))?)
81              .execute(&*self.pool).await
82              .map_err(|error| ServiceError::DatabaseError(error))
83              .map(|result|
84                  if result.rows_affected() == 0 {
85                      Err(ServiceError::CustomError("Zero rows affected".to_string()))
86                  }
87                  else{
88                      Ok(item)
89                  }
90              )
91              .unwrap_or_else(|error|  Err(error))
92      }
93  
94      // Функція для отримання всіх овець
95      async fn get_all(&self) -> Result<Vec<Self::Model>, Self::Error> {
96          query_as::<_, Self::Model>(
97              r#"
98              SELECT * FROM Sheep
99              "#
100         )
101             .fetch_all(&*self.pool).await
102             .map_err(|error| ServiceError::DatabaseError(error))
103     }
104 
105     // Функція для отримання вівці за її ідентифікатором
106     async fn get_by_id(&self, id: u64) -> Result<Option<Self::Model>, Self::Error> {
107         query_as::<_, Self::Model>(
108             r#"
109             SELECT * FROM Sheep
110             WHERE id = ?
111             "#
112         )
113             .bind(id)
114             .fetch_optional(&*self.pool).await
115             .map_err(|error| ServiceError::DatabaseError(error))
116     }
117 }
118 
119 #[async_trait]
120 impl SheepManage<Pool<MySql>> for SheepService<Pool<MySql>>{
121     type SheepDetails = SheepDetailsVM;
122 
123     // Функція для отримання всіх ViewModel овець за ідентифікатором пастуха
124     async fn get_all_vms_by_shepherd_id(&self, id: u64) -> Result<Vec<Self::ViewModel>, Self::Error> {
125         query_as::<_, SheepVM>(
126             r#"
127             SELECT
128             s.id,
129             b.name AS breed,
130             s.sex,
131             s.birth_date,
132             (
133                 SELECT MAX(fl.timestamp)
134                 FROM FeedingLogs fl
135                 WHERE fl.sheep_id = s.id
136             ) AS last_feeding_timestamp,
137             (
138                 SELECT MAX(sl.timestamp)
139                 FROM ShearingLogs sl
140                 WHERE sl.sheep_id = s.id
141             ) AS last_shearing_timestamp
142             FROM Sheep s
143             LEFT JOIN Breeds b ON s.breed_id = b.id
144             WHERE s.shepherd_id = ?
145             "#
146         )
147             .bind(id)
148             .fetch_all(&*self.pool).await
149             .map_err(|error| ServiceError::DatabaseError(error))
150     }
151 
152     // Функція для отримання детальної інформації про вівцю за її ідентифікатором
153     async fn get_details_by_id(&self, id: u64) -> Result<Option<Self::SheepDetails>, Self::Error> {
154         query_as::<_, SheepDetailsVM>(
155             r#"
156             SELECT
157             s.id,
158             b.name AS breed,
159             b.info AS breed_info,
160             s.sex,
161             s.birth_date,
162             (
163                 SELECT MAX(fl.timestamp)
164                 FROM FeedingLogs fl
165                 WHERE fl.sheep_id = s.id
166             ) AS last_feeding_timestamp,
167             (
168                 SELECT MAX(sl.timestamp)
169                 FROM ShearingLogs sl
170                 WHERE sl.sheep_id = s.id
171             ) AS last_shearing_timestamp,
172             s.weight,
173             ts.temperature,
174             f.id AS feed_id,
175             f.name AS feed_name,
176             CAST(ROUND(
177                 CASE
178                     WHEN s.sex = true THEN s.weight * (0.05 + 0.0001 * TIMESTAMPDIFF(DAY, FROM_UNIXTIME(s.birth_date), NOW()))
179                     ELSE s.weight * (0.04 + 0.0001 * TIMESTAMPDIFF(DAY, FROM_UNIXTIME(s.birth_date), NOW()))
180                 END
181             ) AS UNSIGNED) AS required_feed_amount,
182             f.amount AS available_feed_amount
183             FROM Sheep s
184             INNER JOIN Breeds b ON s.breed_id = b.id
185             LEFT JOIN TemperatureScanners ts ON s.temperature_scanner_id = ts.id
186             INNER JOIN Feeds f ON b.feed_id = f.id
187             WHERE s.id = ?
188             "#
189         )
190             .bind(id)
191             .fetch_optional(&*self.pool).await
192             .map_err(|error| ServiceError::DatabaseError(error))
193     }
194 
195     // Функція для зміни пастуха для вівці
196     async fn change_shepherd(&self, sheep_id: u64, shepherd_id: Option<u64>) -> Result<(), Self::Error> {
197         query(
198             r#"
199             UPDATE Sheep
200             SET shepherd_id = ?
201             WHERE id = ?
202             "#
203         )
204             .bind(shepherd_id)
205             .bind(sheep_id)
206             .execute(&*self.pool).await
207             .map_err(|error| ServiceError::DatabaseError(error))
208             .map(|result|
209                 if result.rows_affected() == 0 {
210                     Err(ServiceError::CustomError("Zero rows affected".to_string()))
211                 }
212                 else{
213                     Ok(())
214                 }
215             )
216             .unwrap_or_else(|error| Err(error))
217     }
218 
219     // Функція для зміни сканера температури для вівці
220     async fn change_temperature_scanner(&self, sheep_id: u64, temperature_scanner_id: Option<u64>) -> Result<(), Self::Error> {
221         query(
222             r#"
223             UPDATE Sheep
224             SET temperature_scanner_id = ?
225             WHERE id = ?
226             "#
227         )
228             .bind(temperature_scanner_id)
229             .bind(sheep_id)
230             .execute(&*self.pool).await
231             .map_err(|error| ServiceError::DatabaseError(error))
232             .map(|result|
233                 if result.rows_affected() == 0 {
234                     Err(ServiceError::CustomError("Zero rows affected".to_string()))
235                 }
236                 else{
237                     Ok(())
238                 }
239             )
240             .unwrap_or_else(|error| Err(error))
241     }
242 }

А.3 Модуль sheep_endpoints.rs


 1  #[utoipa::path(responses(
 2      (status = 200, description = "Sheep get all"),
 3      (status = 400, description = "Validation error or bad request"),
 4      (status = 500, description = "Internal server error")
 5  ))]
 6  // Ендпойнт для отримання всіх овець
 7  #[get("/sheep")]
 8  async fn sheep_get_all(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>) -> impl Responder {
 9      let result = sheep_service.get_all().await;
10      send_service_result(result)
11  }
12  
13  #[utoipa::path(params(PathId), responses(
14      (status = 200, description = "Sheep get by id"),
15      (status = 400, description = "Validation error or bad request"),
16      (status = 500, description = "Internal server error")
17  ))]
18  // Ендпойнт для отримання вівці за ідентифікатором
19  #[get("/sheep/{id}")]
20  async fn sheep_get_by_id(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>, params_url: Path<PathId>) -> impl Responder {
21      let params = params_url.into_inner();
22      let result = sheep_service.get_by_id(params.id).await;
23      send_service_result(result)
24  }
25  
26  #[utoipa::path(params(PathId), responses(
27      (status = 200, description = "Sheep get details by id"),
28      (status = 400, description = "Validation error or bad request"),
29      (status = 500, description = "Internal server error")
30  ))]
31  // Ендпойнт для отримання детальної інформації про вівцю за ідентифікатором
32  #[get("/sheep/details/{id}")]
33  async fn sheep_get_details_by_id(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>, params_url: Path<PathId>) -> impl Responder {
34      let params = params_url.into_inner();
35      let result = sheep_service.get_details_by_id(params.id).await;
36      send_service_result(result)
37  }
38  
39  #[utoipa::path(params(PathId), responses(
40      (status = 200, description = "Sheep get all vms by shepherd id"),
41      (status = 400, description = "Validation error or bad request"),
42      (status = 500, description = "Internal server error")
43  ))]
44  // Ендпойнт для отримання всіх ViewModel овець за ідентифікатором пастуха
45  #[get("/sheep/shepherd/{id}")]
46  async fn sheep_get_all_vms_by_shepherd_id(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>, params_url: Path<PathId>) -> impl Responder {
47      let params = params_url.into_inner();
48      let result = sheep_service.get_all_vms_by_shepherd_id(params.id).await;
49      send_service_result(result)
50  }
51  
52  #[utoipa::path(responses(
53      (status = 200, description = "Sheep created"),
54      (status = 400, description = "Validation error or bad request"),
55      (status = 500, description = "Internal server error")
56  ))]
57  // Ендпойнт для створення нової вівці
58  #[post("/sheep/create")]
59  async fn sheep_create(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>, sheep_json: Json<Sheep>) -> impl Responder {
60      let sheep = match validate_json_body(sheep_json) {
61          Ok(sheep) => sheep,
62          Err(error_response) => return error_response,
63      };
64      let result = sheep_service.create(sheep).await;
65      send_service_result(result)
66  }
67  
68  #[utoipa::path(responses(
69      (status = 200, description = "Sheep updated"),
70      (status = 400, description = "Validation error or bad request"),
71      (status = 500, description = "Internal server error")
72  ))]
73  // Ендпойнт для оновлення інформації про вівцю
74  #[put("/sheep/update")]
75  async fn sheep_update(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>, sheep_json: Json<Sheep>) -> impl Responder {
76      let sheep = match validate_json_body(sheep_json) {
77          Ok(sheep) => sheep,
78          Err(error_response) => return error_response,
79      };
80      let result = sheep_service.update(sheep).await;
81      send_service_result(result)
82  }
83  
84  #[utoipa::path(params(PathId), responses(
85      (status = 200, description = "Sheep's shepherd changed"),
86      (status = 400, description = "Validation error or bad request"),
87      (status = 500, description = "Internal server error")
88  ))]
89  // Ендпойнт для зміни пастуха у вівці за ідентифікатором
90  #[patch("/sheep/change-shepherd/{id}")]
91  async fn sheep_change_shepherd(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>, params_url: Path<PathId>, change_shepherd_json: Json<ChangeIdJson>) -> impl Responder {
92      let change_shepherd = change_shepherd_json.into_inner();
93      let params = params_url.into_inner();
94      send_service_message(sheep_service.change_shepherd(params.id, change_shepherd.change_id).await, "Changed")
95  }
96  
97  #[utoipa::path(params(PathId), responses(
98      (status = 200, description = "Sheep's temperature scanner changed"),
99      (status = 400, description = "Validation error or bad request"),
100     (status = 500, description = "Internal server error")
101 ))]
102 // Ендпойнт для зміни сканера температури у вівці за ідентифікатором
103 #[patch("/sheep/change-temperature-scanner/{id}")]
104 async fn sheep_change_temperature_scanner(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>, params_url: Path<PathId>, change_temperature_scanner_json: Json<ChangeIdJson>) -> impl Responder {
105     let change_temperature_scanner = change_temperature_scanner_json.into_inner();
106     let params = params_url.into_inner();
107     send_service_message(sheep_service.change_temperature_scanner(params.id, change_temperature_scanner.change_id).await, "Changed")
108 }
109 
110 #[utoipa::path(params(PathId), responses(
111     (status = 200, description = "Sheep deleted"),
112     (status = 400, description = "Validation error or bad request"),
113     (status = 500, description = "Internal server error")
114 ))]
115 // Ендпойнт для видалення вівці за ідентифікатором
116 #[delete("/sheep/delete/{id}")]
117 async fn sheep_delete(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>, params_url: Path<PathId>) -> impl Responder {
118     let params = params_url.into_inner();
119     send_service_message(sheep_service.delete(params.id).await, "Deleted")
120 }

А.4 Модуль utils.rs


 1  // Функція для валідації JSON тіла запиту
 2  pub(super) fn validate_json_body<T: Validate + Debug>(body: Json<T>) -> Result<T, HttpResponse> {
 3      match body.validate() {
 4          Ok(_) => Ok(body.into_inner()),
 5          Err(error) => {
 6              error!("Validation error of {:?}\nError: {:?}", body, &error);
 7              Err(HttpResponse::BadRequest().json(ServiceError::ValidationError(error).to_string()))
 8          }
 9      }
10  }
11  
12  // Функція для надсилання результату сервісу
13  pub(super) fn send_service_result<T: Serialize + Debug>(result: Result<T, ServiceError>) -> HttpResponse {
14      match result {
15          Ok(res) => {
16              info!("Request result: {:?}", &res);
17              HttpResponse::Ok().json(res)
18          },
19          Err(error) => {
20              error!("Request error: {:?}", &error);
21              HttpResponse::InternalServerError().json(error.to_string())
22          }
23      }
24  }
25  
26  // Функція для надсилання повідомлення сервісу
27  pub(super) fn send_service_message(result: Result<(), ServiceError>, message: &str) -> HttpResponse {
28      match result {
29          Ok(_) => {
30              info!("Request message: {:?}", message);
31              HttpResponse::Ok().json(message)
32          },
33          Err(error) => {
34              error!("Request error: {:?}", &error);
35              HttpResponse::InternalServerError().json(error.to_string())
36          }
37      }
38  }

А.5 Модуль configure.rs


 1  // Конфігурація сервісів для порід
 2  pub(crate) fn breed_configure(cfg: &mut ServiceConfig) {
 3      use breed_endpoints::*;
 4  
 5      cfg.service(breed_create)
 6          .service(breed_delete)
 7          .service(breed_update)
 8          .service(breed_get_all)
 9          .service(breed_get_all_vms)
10          .service(breed_get_by_id);
11  }
12  
13  // Конфігурація сервісів для кормів
14  pub(crate) fn feed_configure(cfg: &mut ServiceConfig) {
15      use feed_endpoints::*;
16  
17      cfg.service(feed_create)
18          .service(feed_delete)
19          .service(feed_update)
20          .service(feed_get_all)
21          .service(feed_get_all_vms)
22          .service(feed_get_by_id);
23  }
24  
25  // Конфігурація сервісів для постачання кормів
26  pub(crate) fn feed_supply_configure(cfg: &mut ServiceConfig) {
27      use feed_supply_endpoints::*;
28  
29      cfg.service(feed_supply_create)
30          .service(feed_supply_delete)
31          .service(feed_supply_get_all)
32          .service(feed_supply_get_all_vms)
33          .service(feed_supply_get_all_vms_by_feed_id)
34          .service(feed_supply_get_by_id);
35  }
36  
37  // Конфігурація сервісів для логів годування
38  pub(crate) fn feeding_log_configure(cfg: &mut ServiceConfig) {
39      use feeding_log_endpoints::*;
40  
41      cfg.service(feeding_log_create)
42          .service(feeding_log_delete)
43          .service(feeding_log_get_all)
44          .service(feeding_log_get_by_id)
45          .service(feeding_log_get_all_vms_by_feed_id)
46          .service(feeding_log_get_all_vms_by_sheep_id);
47  }
48  
49  // Конфігурація сервісів для логів стрижки
50  pub(crate) fn shearing_log_configure(cfg: &mut ServiceConfig) {
51      use shearing_log_endpoints::*;
52  
53      cfg.service(shearing_log_create)
54          .service(shearing_log_delete)
55          .service(shearing_log_get_all)
56          .service(shearing_log_get_by_id)
57          .service(shearing_log_get_all_vms_by_sheep_id);
58  }
59  
60  // Конфігурація сервісів для овець
61  pub(crate) fn sheep_configure(cfg: &mut ServiceConfig) {
62      use sheep_endpoints::*;
63  
64      cfg.service(sheep_create)
65          .service(sheep_delete)
66          .service(sheep_update)
67          .service(sheep_change_temperature_scanner)
68          .service(sheep_change_shepherd)
69          .service(sheep_get_all)
70          .service(sheep_get_all_vms_by_shepherd_id)
71          .service(sheep_get_by_id)
72          .service(sheep_get_details_by_id);
73  }
74  
75  // Конфігурація сервісів для пастухів
76  pub(crate) fn shepherd_configure(cfg: &mut ServiceConfig) {
77      use shepherd_endpoints::*;
78  
79      cfg.service(shepherd_create)
80          .service(shepherd_delete)
81          .service(shepherd_update)
82          .service(shepherd_authorize)
83          .service(shepherd_get_all)
84          .service(shepherd_get_by_id)
85          .service(shepherd_get_all_vms);
86  }
87  
88  // Конфігурація сервісів для комірників
89  pub(crate) fn storekeeper_configure(cfg: &mut ServiceConfig) {
90      use storekeeper_endpoints::*;
91  
92      cfg.service(storekeeper_create)
93          .service(storekeeper_delete)
94          .service(storekeeper_update)
95          .service(storekeeper_authorize)
96          .service(storekeeper_get_all)
97          .service(storekeeper_get_by_id);
98  }
99  
100  // Конфігурація сервісів для сканерів температури
101 pub(crate) fn temperature_scanner_configure(cfg: &mut ServiceConfig) {
102     use temperature_scanner_endpoints::*;
103 
104     cfg.service(temperature_scanner_create)
105         .service(temperature_scanner_delete)
106         .service(temperature_scanner_update)
107         .service(temperature_scanner_update_temperature)
108         .service(temperature_scanner_authenticate)
109         .service(temperature_scanner_get_all)
110         .service(temperature_scanner_get_by_id)
111         .service(temperature_scanner_get_all_unassigned_scanners_ids);
112 }

ДОДАТОК Б
Код реалізації логіки IoT частини

Б.1 Файл main.rs


1  // Головна асинхронна функція
2  #[tokio::main]
3  async fn main() -> ! {
4      // Завантаження змінних середовища з файлу .env
5      dotenv().ok();
6
7      // Отримання URL сервера зі змінної середовища
8      let server_url: String = match env::var("SERVER_URL") {
9          Ok(url) => url,
10         Err(error) => panic(&error.to_string()) // Виклик паніки у разі помилки
11     };
12
13     // Читання та форматування аргументів командного рядка для аутентифікації
14     let auth = match read_and_format_cli_arguments() {
15         Ok(auth) => auth,
16         Err(error) => {
17             panic(&error.to_string()) // Виклик паніки у разі помилки
18         }
19     };
20
21     // Аутентифікація на сервері
22     if let Err(error) = authenticate(&auth, &server_url).await {
23         panic(&error.to_string()) // Виклик паніки у разі помилки
24     }
25
26     // Початкова температура
27     let mut temperature: u16 = 370;
28
29     // Основний цикл програми
30     loop {
31         // Читання температури
32         temperature = read_temperature(temperature);
33
34         // Надсилання температури на сервер
35         match send_temperature(auth.id, temperature, &server_url).await {
36             Ok(result) => {
37                 display(&format!("{}", result)); // Відображення результату
38                 sleepAsync(Duration::from_millis(5000)).await; // Затримка на 5 секунд
39             },
40             Err(error) => {
41                 display(&format!("Fix and try again. {}", error.to_string())); // Відображення помилки
42                 continue_action(); // Продовження дії після помилки
43             }
44         }
45     }
46 }

Б.2 Модуль utils.rs


1  // Функція для відображення повідомлення
2  pub(crate) fn display(message: &str) -> () {
3      println!("{}", message);
4  }
5
6  // Функція для продовження дії після введення користувачем
7  pub(crate) fn continue_action() -> () {
8      display("Press ENTER to try again.");  // Відображення повідомлення
9      let mut input = String::new();
10     if let Err(error) = io::stdin().read_line(&mut input) {  // Зчитування введення користувача
11         panic(&error.to_string())  // Виклик функції panic у разі помилки
12     }
13 }
14
15 // Функція для паніки з повідомленням
16 pub(crate) fn panic(message: &str) -> ! {
17     display(&message.to_string());  // Відображення повідомлення про паніку
18     loop {
19         sleep(Duration::from_millis(100000))  // Затримка для імітації нескінченного циклу
20     }
21 }

Б.3 Модуль auth.rs


1  // Структура для збереження аутентифікаційних даних
2  pub(crate) struct TemperatureScannerAuthJson {
3      pub id: u64,
4      pub password: String,
5  }
6
7  // Функція для зчитування та форматування аргументів командного рядка
8  pub(crate) fn read_and_format_cli_arguments() -> Result<TemperatureScannerAuthJson, ScannerError> {
9      let mut id_input = String::new();
10     let mut password_input = String::new();
11
12     // Запит введення ідентифікатора сканера
13     print!("Provide scanner ID: ");
14     if let Err(error) = io::stdout().flush() {
15         return Err(ScannerError::ArgumentsError(error.to_string()));
16     }
17     if let Err(error) = io::stdin().read_line(&mut id_input) {
18         return Err(ScannerError::ArgumentsError(error.to_string()));
19     }
20     // Парсинг введеного ідентифікатора
21     let id: u64 = match id_input.trim().parse() {
22         Ok(id) => id,
23         Err(error) => return Err(ScannerError::ArgumentsError(error.to_string()))
24     };
25
26     // Запит введення пароля сканера
27     print!("Provide scanner password: ");
28     if let Err(error) = io::stdout().flush() {
29         return Err(ScannerError::ArgumentsError(error.to_string()));
30     }
31     if let Err(error) = io::stdin().read_line(&mut password_input) {
32         return Err(ScannerError::ArgumentsError(error.to_string()));
33     }
34     let password = password_input.trim().to_string();
35
36     // Повернення структури з аутентифікаційними даними
37     Ok(TemperatureScannerAuthJson { id, password })
38 }
39
40 // Функція для аутентифікації на сервері
41 pub(crate) async fn authenticate(auth: &TemperatureScannerAuthJson, server_url: &str) -> Result<(), ScannerError> {
42     let client = Client::new();
43     let url = format!("{}authenticate/{}", server_url, auth.id);
44     let body = object!{
45         password: *auth.password,
46     }.dump();
47
48     // Надсилання POST-запиту на сервер
49     let response = match client.post(&url).header("Content-Type", "application/json").body(body).send().await {
50         Ok(res) => res,
51         Err(error) => return Err(ScannerError::AuthenticationError(error.to_string()))
52     };
53
54     // Обробка відповіді від сервера
55     match response.json::<bool>().await {
56         Ok(result) => if result {
57             Ok(())
58         } else {
59             Err(ScannerError::AuthenticationError("This device failed authentication".to_string()))
60         },
61         Err(error) => Err(ScannerError::AuthenticationError(error.to_string()))
62     }
63 }

Б.4 Модуль temperature.rs


1  // Функція для зчитування температури
2  pub(crate) fn read_temperature(previous_temp: u16) -> u16 {
3      let mut rng = rand::thread_rng();
4      let min_temp = 360;  // Мінімальна температура
5      let max_temp = 400;  // Максимальна температура
6      let step = 1;        // Крок зміни температури
7
8      // Обчислення нової температури
9      let new_temp = if previous_temp < min_temp {
10         min_temp
11     } else if previous_temp > max_temp {
12         max_temp
13     } else {
14         let delta = rng.gen_range(-step..=step);  // Випадкове значення зміни температури
15         let temp = previous_temp as i16 + delta;
16         temp.max(min_temp as i16).min(max_temp as i16) as u16
17     };
18     display(&format!("Temperature is {}", new_temp));  // Відображення нової температури
19     new_temp
20 }
21
22 // Асинхронна функція для відправки температури на сервер
23 pub(crate) async fn send_temperature(id: u64, temp: u16, server_url: &str) -> Result<String, ScannerError>  {
24     let client = Client::new();
25     let url = format!("{}update-temperature/{}", server_url, id);  // Формування URL для запиту
26
27     let body = object!{
28             temperature: temp,
29     }.dump();  // Формування тіла запиту
30
31     // Відправка запиту на сервер
32     let response = match client.patch(&url).header("Content-Type", "application/json").body(body).send().await{
33         Ok(res) => res,
34         Err(error) => return Err(ScannerError::UpdatingError(error.to_string()))
35     };
36
37     // Обробка відповіді сервера
38     match response.json().await{
39         Ok(text) => Ok(text),
40         Err(error) => return Err(ScannerError::UpdatingError(error.to_string()))
41     }
42 }

Б.5 Модуль scanner_error.rs


1  // Перерахування можливих помилок сканера
2  #[derive(Debug)]
3  pub(crate) enum ScannerError {
4      ArgumentsError(String),          // Помилка аргументів
5      UpdatingError(String),           // Помилка оновлення температури
6      AuthenticationError(String)      // Помилка аутентифікації
7  }
8  
9  // Реалізація Display для ScannerError
10 impl Display for ScannerError {
11     fn fmt(&self, formatter: &mut Formatter<'_>) -> std::fmt::Result {
12         match &self {
13             // Форматування помилки аргументів
14             ScannerError::ArgumentsError(error) => write!(formatter, "Arguments error: {}.\nPlease restart device and try again", error),
15             // Форматування помилки оновлення температури
16             ScannerError::UpdatingError(error) => write!(formatter, "Updating temperature error: {}", error),
17             // Форматування помилки аутентифікації
18             ScannerError::AuthenticationError(error) => write!(formatter, "Authentication error: {}. \nPlease restart device and try again", error)
19         }
20     }
21 }
22
23 // Реалізація Error для ScannerError
24 impl Error for ScannerError { }

ДОДАТОК В
Код реалізації логіки веб-клієнта

В.1 Компонент Router.tsx


1  export const Router = () => {
2    // Стан для зберігання авторизованого користувача
3    const [user, setUser] = useState<AuthUser>(new AuthUser(null, UserRole.Unauthorized));
4
5    // Функція для виходу з системи
6    const logout = () => {
7      const unauthorized_user = new AuthUser(null, UserRole.Unauthorized);
8      saveAuthUserToLocalStorage("user", unauthorized_user);
9      setUser(unauthorized_user);
10   }
11
12   // Використання useEffect для завантаження користувача з Local Storage при завантаженні компонента
13   useEffect(() => {
14     const result = getAuthUserFromLocalStorage("user");
15     if (result.Id != null && user.Id == null) {
16       setUser(new AuthUser(result.Id, result.Role));
17     }
18   }, [user])
19
20   // Використання i18n для багатомовності
21   const { t, i18n } = useTranslation();
22
23   // Функція для зміни мови
24   const changeLanguage = (lng?: string | undefined) => {
25     i18n.changeLanguage(lng);
26   };
27
28   return (
29     <div className={styles.container}>
30       <BrowserRouter>
31         <header className={styles.header}>
32           <button className={styles.button} style={{ minWidth: "200px" }} onClick={() => changeLanguage(i18n.language === 'en' ? 'ua' : 'en')}>
33             {t('router.switchButtonText')}
34           </button>
35           {user.Role != UserRole.Unauthorized && (
36             <div className={styles.buttonContainer}>
37               <button className={styles.button} onClick={logout}>{t('router.logoutButtonText')}</button>
38             </div>
39           )}
40         </header>
41         <div className={styles.content}>
42           <Routes>
43             <Route path="/" element={<App user={user} setUser={setUser} />} />
44             <Route path="/sheep/:sheepId" element={<SheepMainPage user={user} setUser={setUser} />} />
45             <Route path="/feed/:feedId" element={<FeedPage user={user} setUser={setUser} />} />
46             <Route path="/create/feed-supply/:feedId" element={<CreateFeedSupplyForm user={user} setUser={setUser} />} />
47             <Route path="/shepherd/create" element={<AdminBaseForm user={user} setUser={setUser} entityType="Shepherd" />} />
48             <Route path="/shepherd/edit/:entityId" element={<AdminBaseForm user={user} setUser={setUser} entityType="Shepherd" />} />
49             <Route path="/storekeeper/create" element={<AdminBaseForm user={user} setUser={setUser} entityType="Storekeeper" />} />
50             <Route path="/storekeeper/edit/:entityId" element={<AdminBaseForm user={user} setUser={setUser} entityType="Storekeeper" />} />
51             <Route path="/sheep/create" element={<AdminBaseForm user={user} setUser={setUser} entityType="Sheep" />} />
52             <Route path="/sheep/edit/:entityId" element={<AdminBaseForm user={user} setUser={setUser} entityType="Sheep" />} />
53             <Route path="/sheep/reassign-shepherd/:sheepId" element={<ReassignFormForSheep user={user} setUser={setUser} entityType="Shepherd" />} />
54             <Route path="/sheep/reassign-temperature-scanner/:sheepId" element={<ReassignFormForSheep user={user} setUser={setUser} entityType="TemperatureScanner" />} />
55             <Route path="/feed/create" element={<AdminBaseForm user={user} setUser={setUser} entityType="Feed" />} />
56             <Route path="/feed/edit/:entityId" element={<AdminBaseForm user={user} setUser={setUser} entityType="Feed" />} />
57             <Route path="/breed/create" element={<AdminBaseForm user={user} setUser={setUser} entityType="Breed" />} />
58             <Route path="/breed/edit/:entityId" element={<AdminBaseForm user={user} setUser={setUser} entityType="Breed" />} />
59             <Route path="/temperature-scanner/create" element={<AdminBaseForm user={user} setUser={setUser} entityType="TemperatureScanner" />} />
60             <Route path="/temperature-scanner/edit/:entityId" element={<AdminBaseForm user={user} setUser={setUser} entityType="TemperatureScanner" />} />
61             <Route path="*" element={<div>Not Found 404</div>} />
62           </Routes>
63         </div>
64       </BrowserRouter>
65       <footer className={styles.footer}>
66         © 2024 Wool Farm Management System
67       </footer>
68     </div>
69   )
70 };

В.2 Файл SheepService.ts


1  export class SheepService implements ISheepService<SheepDetailsVM> {
2      // Статичні URL-адреси для запитів до API
3      private static SHEEP_URLS = {
4          GET_ALL: `${API_URL}/sheep`, // URL для отримання всіх овець
5          GET_BY_ID: (id: number) => `${API_URL}/sheep/${id}`, // URL для отримання вівці за ідентифікатором
6          CREATE: `${API_URL}/sheep/create`, // URL для створення нової вівці
7          DELETE: (id: number) => `${API_URL}/sheep/delete/${id}`, // URL для видалення вівці за ідентифікатором
8          UPDATE: `${API_URL}/sheep/update`, // URL для оновлення вівці
9          GET_ALL_VMS_BY_SHEPHERD_ID: (id: number) => `${API_URL}/sheep/shepherd/${id}`, // URL для отримання всіх моделей представлення овець за ідентифікатором пастуха
10         GET_DETAILS_BY_ID: (id: number) => `${API_URL}/sheep/details/${id}`, // URL для отримання детальної інформації про вівцю за ідентифікатором
11         CHANGE_SHEPHERD: (sheepId: number) => `${API_URL}/sheep/change-shepherd/${sheepId}`, // URL для зміни пастуха у вівці
12         CHANGE_TEMPERATURE_SCANNER: (sheepId: number) => `${API_URL}/sheep/change-temperature-scanner/${sheepId}` // URL для зміни температурного сканера у вівці
13     }
14 
15     // Метод для створення нової вівці
16     async create(item: Sheep): Promise<Sheep> {
17         const response = await axios.post<Sheep>(SheepService.SHEEP_URLS.CREATE, item);
18         return response.data;
19     }
20 
21     // Метод для видалення вівці за ідентифікатором
22     async delete(itemId: number): Promise<void> {
23         await axios.delete(SheepService.SHEEP_URLS.DELETE(itemId));
24     }
25 
26     // Метод для оновлення існуючої вівці
27     async update(item: Sheep): Promise<Sheep> {
28         const response = await axios.put<Sheep>(SheepService.SHEEP_URLS.UPDATE, item);
29         return response.data;
30     }
31 
32     // Метод для отримання всіх овець
33     async getAll(): Promise<Sheep[]> {
34         const response = await axios.get<Sheep[]>(SheepService.SHEEP_URLS.GET_ALL);
35         return response.data;
36     }
37 
38     // Метод для отримання вівці за ідентифікатором
39     async getById(id: number): Promise<Sheep | null> {
40         const response = await axios.get<Sheep | null>(SheepService.SHEEP_URLS.GET_BY_ID(id));
41         return response.data;
42     }
43 
44     // Метод для отримання всіх моделей представлення овець за ідентифікатором пастуха
45     async getAllVMsByShepherdId(id: number): Promise<SheepVM[]> {
46         const response = await axios.get<[]>(SheepService.SHEEP_URLS.GET_ALL_VMS_BY_SHEPHERD_ID(id));
47         const vms: SheepVM[] = [];
48         response.data.map(sheep => {
49             //@ts-ignore
50             vms.push(new SheepVM(sheep.id, sheep.breed, sheep.sex, sheep.birth_date, sheep.last_feeding_timestamp, sheep.last_shearing_timestamp));
51         });
52         return vms;
53     }
54 
55     // Метод для отримання детальної інформації про вівцю за ідентифікатором
56     async getDetailsById(id: number): Promise<SheepDetailsVM | null> {
57         const response = await axios.get(SheepService.SHEEP_URLS.GET_DETAILS_BY_ID(id));
58         const sheepDetails = response.data;
59         if (sheepDetails) {
60             //@ts-ignore
61             return new SheepDetailsVM(
62                 sheepDetails.id,
63                 sheepDetails.breed,
64                 sheepDetails.breed_info,
65                 sheepDetails.sex,
66                 sheepDetails.birth_date,
67                 sheepDetails.weight,
68                 sheepDetails.feed_id,
69                 sheepDetails.feed_name,
70                 sheepDetails.required_feed_amount,
71                 sheepDetails.available_feed_amount,
72                 sheepDetails.last_feeding_timestamp,
73                 sheepDetails.last_shearing_timestamp,
74                 sheepDetails.temperature
75             );
76         }
77         return null;
78     }
79 
80     // Метод для зміни пастуха у вівці
81     async changeShepherd(sheepId: number, changeId: number | null): Promise<void> {
82         await axios.patch<void>(SheepService.SHEEP_URLS.CHANGE_SHEPHERD(sheepId), { change_id: changeId });
83     }
84 
85     // Метод для зміни температурного сканера у вівці
86     async changeTemperatureScanner(sheepId: number, changeId: number | null): Promise<void> {
87         await axios.patch<void>(SheepService.SHEEP_URLS.CHANGE_TEMPERATURE_SCANNER(sheepId), { change_id: changeId });
88     }
89 }

В.3 Модуль helpers.ts


1  // Функція для конвертації мітки часу в дату у форматі "гг:хх дд.мм.рррр"
2  export const timestampToDate = (timestamp: number): string => {
3    let date = new Date(timestamp * 1000);
4    let hours = date.getHours().toString().padStart(2, '0');
5    let minutes = date.getMinutes().toString().padStart(2, '0');
6    let day = date.getDate();
7    let month = (date.getMonth() + 1).toString().padStart(2, '0');
8    let year = date.getFullYear();
9    return `${hours}:${minutes} ${day}.${month}.${year}`;
10 }
11 
12 // Функція для збереження авторизованого користувача в Local Storage
13 export const saveAuthUserToLocalStorage = (key: string, value: AuthUser) => {
14   try {
15       const serializedValue = JSON.stringify({
16           Id: value.Id,
17           Role: value.Role
18       });
19       localStorage.setItem(key, serializedValue);
20   } catch (error) {
21       console.error('Error saving to Local Storage:', error);
22   }
23 };
24 
25 // Функція для отримання авторизованого користувача з Local Storage
26 export const getAuthUserFromLocalStorage = (key: string): AuthUser => {
27   try {
28       const serializedValue = JSON.parse(localStorage.getItem(key) as string);
29       if (serializedValue != null) {
30           //@ts-ignore
31           return new AuthUser(serializedValue.Id, serializedValue.Role);
32       }
33       return new AuthUser(null, UserRole.Unauthorized);
34   } catch (error) {
35       console.error('Error retrieving from Local Storage:', error);
36       return new AuthUser(null, UserRole.Unauthorized);
37   }
38 };
39 
40 // Функція для хешування пароля
41 export const hashPassword = async (password: string) => {
42   const encoder = new TextEncoder();
43   const data = encoder.encode(password);
44 
45   const hashBuffer = await crypto.subtle.digest('SHA-256', data);
46   const hashArray = Array.from(new Uint8Array(hashBuffer));
47   const hashedPassword = hashArray.map((byte) => ('00' + byte.toString(16)).slice(-2)).join('');
48 
49   return hashedPassword;
50 };
51 
52 // Функція для перевірки користувача та навігації
53 export const useEffectUser = (dependency: AuthUser, navigate: NavigateFunction) => {
54   useEffect(() => {
55       const result = getAuthUserFromLocalStorage("user");
56       if (result.Id == null) {
57           navigate("/");
58       }
59   }, [dependency])
60 };
61 
62 // Функція для обробки зміни елементів
63 export const handleElementChange = (e: React.ChangeEvent<HTMLInputElement> | React.ChangeEvent<HTMLSelectElement> | React.ChangeEvent<HTMLTextAreaElement>, setChanges: (value: React.SetStateAction<any>) => void) => {
64   setChanges(e.target.value);
65 };
66 
67 // Функція для обчислення часу в днях з мітки часу
68 export const timeInDays = (timestamp: number | null): number => {
69   if (timestamp == null) {
70       return Infinity;
71   }
72   const difference = (new Date().getTime() - timestamp * 1000);
73   const days = difference / 1000 / 3600 / 24;
74   return Math.floor(days);
75 };

ДОДАТОК Г
Графічни інтерфейси веб-клієнта


Рисунок Г.1 — Форма авторизації


Рисунок Г.2 — Головна сторінка вівчаря


Рисунок Г.3 — Сторінка з деталями про вівцю


Рисунок Г.4 — Головна сторінка адміністартора


Рисунок Г.5 — Головна сторінка комірника
